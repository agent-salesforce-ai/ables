<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNOOD SINDICAL - Official Union Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(255, 0, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(255, 200, 0, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            pointer-events: none;
            z-index: 1000;
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        .main-panel { display: flex; flex-direction: column; align-items: center; }

        .header { text-align: center; padding: 15px; }

        .title {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 3px 3px 0 #000;
            margin-bottom: 5px;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }

        .subtitle {
            font-size: 20px;
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }

        .score-display {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 10px;
        }

        .score-box {
            background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 3px solid #ff0000;
            border-radius: 10px;
            padding: 12px 25px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        .score-label { font-size: 16px; color: #888; }
        .score-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        .player-name-display { font-size: 14px; color: #ffcc00; margin-top: 3px; }

        #gameCanvas {
            border: 4px solid #ff0000;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            background: linear-gradient(180deg, #0d0d1a 0%, #1a0a1a 100%);
            cursor: crosshair;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-top: 10px;
            padding: 0 10px;
        }

        .level-display { font-size: 18px; color: #ff8800; text-shadow: 0 0 10px #ff8800; }
        .combo-display { font-size: 18px; color: #ff00ff; text-shadow: 0 0 10px #ff00ff; }

        .side-panel {
            background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 3px solid #ffcc00;
            border-radius: 15px;
            padding: 20px;
            min-width: 260px;
            box-shadow: 0 0 30px rgba(255, 200, 0, 0.3);
        }

        .leaderboard-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: #ffcc00;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffcc00;
        }

        .leaderboard-list { list-style: none; }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid transparent;
        }

        .leaderboard-entry:nth-child(1) { border-left-color: #ffd700; background: rgba(255, 215, 0, 0.15); }
        .leaderboard-entry:nth-child(2) { border-left-color: #c0c0c0; background: rgba(192, 192, 192, 0.1); }
        .leaderboard-entry:nth-child(3) { border-left-color: #cd7f32; background: rgba(205, 127, 50, 0.1); }

        .leaderboard-rank { color: #888; font-size: 16px; min-width: 25px; }
        .leaderboard-name { color: #fff; font-size: 16px; flex-grow: 1; margin-left: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100px; }
        .leaderboard-score { color: #00ff00; font-family: 'Press Start 2P', cursive; font-size: 10px; }

        .no-scores { color: #666; text-align: center; font-size: 14px; padding: 20px; }

        .clear-scores-btn {
            display: block;
            width: 100%;
            margin-top: 15px;
            padding: 8px;
            background: transparent;
            border: 1px solid #ff4444;
            color: #ff4444;
            font-family: 'VT323', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
        }
        .clear-scores-btn:hover { background: #ff4444; color: #000; }

        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .overlay.hidden { display: none; }

        .overlay-content {
            background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 4px solid #ff0000;
            border-radius: 20px;
            padding: 35px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
            max-width: 450px;
            width: 90%;
        }

        .overlay-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 22px;
            color: #ff0000;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #ff0000;
        }

        .overlay-subtitle { font-size: 22px; color: #ffcc00; margin-bottom: 25px; }

        .name-input-container { margin: 25px 0; }
        .name-input-label { font-size: 18px; color: #fff; margin-bottom: 10px; display: block; }

        .name-input {
            background: #0a0a1a;
            border: 3px solid #ffcc00;
            border-radius: 10px;
            padding: 12px 18px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #00ff00;
            text-align: center;
            width: 100%;
            max-width: 280px;
            text-transform: uppercase;
            outline: none;
        }
        .name-input:focus { border-color: #00ff00; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3); }
        .name-input::placeholder { color: #444; }

        .btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 18px 35px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            margin: 8px;
        }

        .btn-primary {
            background: linear-gradient(180deg, #ff0000 0%, #aa0000 100%);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5), 0 5px 0 #660000;
        }
        .btn-primary:hover { transform: translateY(-3px); box-shadow: 0 0 30px rgba(255, 0, 0, 0.7), 0 8px 0 #660000; }
        .btn-primary:active { transform: translateY(2px); }

        .btn-secondary {
            background: linear-gradient(180deg, #333 0%, #111 100%);
            color: #ffcc00;
            border: 2px solid #ffcc00;
        }
        .btn-secondary:hover { background: linear-gradient(180deg, #ffcc00 0%, #ff8800 100%); color: #000; }

        .btn-share {
            background: linear-gradient(180deg, #00aa00 0%, #006600 100%);
            color: #fff;
            border: 2px solid #00ff00;
        }
        .btn-share:hover { background: linear-gradient(180deg, #00ff00 0%, #00aa00 100%); color: #000; }

        .share-copied {
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: #00ff00;
            margin-top: 10px;
            animation: fadeInOut 2s ease-in-out forwards;
        }
        .share-copied.hidden { display: none; }
        @keyframes fadeInOut { 0% { opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }

        .final-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 42px;
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            margin: 15px 0;
        }

        .game-stats { display: flex; justify-content: center; gap: 25px; margin: 15px 0; flex-wrap: wrap; }
        .stat-item { text-align: center; }
        .stat-label { font-size: 14px; color: #888; }
        .stat-value { font-size: 20px; color: #ffcc00; }

        .new-high-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: #ffd700;
            animation: highScorePulse 0.5s ease-in-out infinite alternate;
            margin-top: 10px;
        }
        @keyframes highScorePulse { from { opacity: 0.5; transform: scale(1); } to { opacity: 1; transform: scale(1.1); } }
        .new-high-score.hidden { display: none; }

        .footer { text-align: center; padding: 15px; color: #ff0000; font-size: 16px; text-shadow: 0 0 10px #ff0000; }

        .instructions { font-size: 15px; color: #888; margin: 15px 0; line-height: 1.5; }
        .instructions span { color: #ffcc00; }

        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 24px;
            animation: floatUp 2s ease-out forwards;
            z-index: 50;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-150px) scale(0.5); } }

        .combo-popup {
            position: fixed;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            animation: comboFade 1s ease-out forwards;
            z-index: 50;
        }
        @keyframes comboFade { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(1.5); } }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div class="overlay" id="nameOverlay">
        <div class="overlay-content">
            <div class="overlay-title">SNOOD SINDICAL</div>
            <div class="overlay-subtitle">OFFICIAL GAME OF THE UNION</div>
            <div class="name-input-container">
                <label class="name-input-label">ENTER YOUR NAME, COMRADE:</label>
                <input type="text" id="playerNameInput" class="name-input" placeholder="YOUR NAME" maxlength="12" autocomplete="off">
            </div>
            <div class="instructions">
                <span>AIM</span> with mouse | <span>CLICK</span> to shoot<br>
                Match <span>3+</span> to clear | Don't hit the <span>DANGER ZONE</span>
            </div>
            <button class="btn btn-primary" id="startGameBtn">VIVA LA REVOLUCION!</button>
        </div>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
        <div class="overlay-content">
            <div class="overlay-title" id="gameOverTitle">MANAGEMENT WINS</div>
            <div class="final-score" id="finalScore">0</div>
            <div class="game-stats">
                <div class="stat-item"><div class="stat-label">LEVEL</div><div class="stat-value" id="finalLevel">1</div></div>
                <div class="stat-item"><div class="stat-label">MAX COMBO</div><div class="stat-value" id="finalCombo">0</div></div>
                <div class="stat-item"><div class="stat-label">CLEARED</div><div class="stat-value" id="finalCleared">0</div></div>
            </div>
            <div class="new-high-score hidden" id="newHighScore">NEW HIGH SCORE!</div>
            <button class="btn btn-primary" id="playAgainBtn">OTRA VEZ!</button>
            <button class="btn btn-secondary" id="changeNameBtn">CHANGE NAME</button>
            <button class="btn btn-share" id="shareScoreBtn">SHARE SCORE</button>
            <div class="share-copied hidden" id="shareCopied">COPIED TO CLIPBOARD!</div>
        </div>
    </div>

    <div class="game-container">
        <div class="main-panel">
            <div class="header">
                <h1 class="title">SNOOD SINDICAL</h1>
                <p class="subtitle">OFFICIAL GAME OF THE UNION</p>
            </div>

            <div class="score-display">
                <div class="score-box">
                    <div class="score-label">SCORE</div>
                    <div class="score-value" id="score">0</div>
                    <div class="player-name-display" id="currentPlayerName">-</div>
                </div>
                <div class="score-box">
                    <div class="score-label">HIGH SCORE</div>
                    <div class="score-value" id="highScore">0</div>
                    <div class="player-name-display" id="highScoreHolder">-</div>
                </div>
            </div>

            <canvas id="gameCanvas" width="500" height="550"></canvas>

            <div class="game-info">
                <div class="level-display">LEVEL: <span id="level">1</span></div>
                <div class="combo-display">COMBO: <span id="combo">x1</span></div>
            </div>
        </div>

        <div class="side-panel">
            <div class="leaderboard-title">UNION HALL OF FAME</div>
            <ul class="leaderboard-list" id="leaderboard">
                <li class="no-scores">No scores yet!</li>
            </ul>
            <button class="clear-scores-btn" id="clearScoresBtn">CLEAR SCORES</button>
        </div>
    </div>

    <div class="footer">PROPERTY OF LOS UNION - WORKERS UNITE!</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Polyfill for roundRect
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        const SNOOD_RADIUS = 20;
        const ROW_HEIGHT = SNOOD_RADIUS * 1.73;
        const COLS = 12;
        const DANGER_LINE = canvas.height - 80;
        const SHOOT_Y = canvas.height - 50;

        const SNOOD_TYPES = [
            { emoji: '\u270A', color: '#ff0000' },
            { emoji: '\uD83D\uDCB0', color: '#00dd00' },
            { emoji: '\u26A0\uFE0F', color: '#ffff00' },
            { emoji: '\uD83D\uDCE2', color: '#0088ff' },
            { emoji: '\uD83D\uDD25', color: '#ff8800' },
            { emoji: '\u2694\uFE0F', color: '#dd00ff' },
            { emoji: '\u2615', color: '#ff0099' },
            { emoji: '\uD83E\uDD16', color: '#00ffff' }
        ];

        let grid = [], currentSnood = null, nextSnood = null, shootingSnood = null;
        let score = 0, level = 1, combo = 1, maxCombo = 1, totalCleared = 0;
        let gameOver = false, gameStarted = false, aimAngle = -Math.PI / 2;
        let playerName = '', animating = false;

        let leaderboard = JSON.parse(localStorage.getItem('snoodLeaderboard')) || [];

        const nameOverlay = document.getElementById('nameOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const playerNameInput = document.getElementById('playerNameInput');

        function init() {
            updateLeaderboardDisplay();
            updateHighScoreDisplay();
            const saved = localStorage.getItem('snoodPlayerName');
            if (saved) playerNameInput.value = saved;
            playerNameInput.focus();
        }

        function startGame() {
            playerName = playerNameInput.value.trim().toUpperCase() || 'ANON';
            localStorage.setItem('snoodPlayerName', playerName);
            document.getElementById('currentPlayerName').textContent = playerName;
            nameOverlay.classList.add('hidden');
            resetGame();
            gameStarted = true;
            gameLoop();
        }

        function resetGame() {
            grid = []; score = 0; level = 1; combo = 1; maxCombo = 1; totalCleared = 0;
            gameOver = false; animating = false;

            for (let row = 0; row < 5; row++) {
                grid[row] = [];
                const offset = row % 2 === 0 ? 0 : SNOOD_RADIUS;
                for (let col = 0; col < COLS - (row % 2); col++) {
                    grid[row][col] = {
                        type: Math.floor(Math.random() * Math.min(5 + level, SNOOD_TYPES.length)),
                        x: col * SNOOD_RADIUS * 2 + SNOOD_RADIUS + offset,
                        y: row * ROW_HEIGHT + SNOOD_RADIUS + 20
                    };
                }
            }
            currentSnood = createSnood();
            nextSnood = createSnood();
            updateDisplay();
        }

        function createSnood() {
            return { type: Math.floor(Math.random() * Math.min(5 + Math.floor(level/2), SNOOD_TYPES.length)), x: canvas.width/2, y: SHOOT_Y };
        }

        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('combo').textContent = 'x' + combo;
        }

        function updateHighScoreDisplay() {
            if (leaderboard.length > 0) {
                document.getElementById('highScore').textContent = leaderboard[0].score;
                document.getElementById('highScoreHolder').textContent = leaderboard[0].name;
            }
        }

        function updateLeaderboardDisplay() {
            const list = document.getElementById('leaderboard');
            list.innerHTML = '';
            if (leaderboard.length === 0) {
                list.innerHTML = '<li class="no-scores">No scores yet!</li>';
                return;
            }
            leaderboard.slice(0, 10).forEach((e, i) => {
                const li = document.createElement('li');
                li.className = 'leaderboard-entry';
                li.innerHTML = `<span class="leaderboard-rank">${i+1}.</span><span class="leaderboard-name">${e.name}</span><span class="leaderboard-score">${e.score}</span>`;
                list.appendChild(li);
            });
        }

        function saveScore() {
            const entry = { name: playerName, score, level, date: Date.now() };
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 100);
            localStorage.setItem('snoodLeaderboard', JSON.stringify(leaderboard));
            updateLeaderboardDisplay();
            updateHighScoreDisplay();
            return leaderboard[0].score === score;
        }

        canvas.addEventListener('mousemove', (e) => {
            if (gameOver || !gameStarted || shootingSnood) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            aimAngle = Math.atan2(my - SHOOT_Y, mx - canvas.width/2);
            aimAngle = Math.max(-Math.PI + 0.15, Math.min(-0.15, aimAngle));
        });

        canvas.addEventListener('click', () => {
            if (gameOver || !gameStarted || shootingSnood || animating) return;
            shoot();
        });

        function shoot() {
            const speed = 14;
            shootingSnood = { ...currentSnood, vx: Math.cos(aimAngle) * speed, vy: Math.sin(aimAngle) * speed };
            currentSnood = nextSnood;
            currentSnood.x = canvas.width/2;
            currentSnood.y = SHOOT_Y;
            nextSnood = createSnood();
        }

        function update() {
            if (!shootingSnood) return;
            shootingSnood.x += shootingSnood.vx;
            shootingSnood.y += shootingSnood.vy;

            if (shootingSnood.x < SNOOD_RADIUS || shootingSnood.x > canvas.width - SNOOD_RADIUS) {
                shootingSnood.vx *= -1;
                shootingSnood.x = Math.max(SNOOD_RADIUS, Math.min(canvas.width - SNOOD_RADIUS, shootingSnood.x));
            }

            if (shootingSnood.y < SNOOD_RADIUS + 20) { snap(0); return; }

            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < (grid[r]?.length || 0); c++) {
                    const s = grid[r][c];
                    if (s) {
                        const dx = shootingSnood.x - s.x, dy = shootingSnood.y - s.y;
                        if (Math.sqrt(dx*dx + dy*dy) < SNOOD_RADIUS * 2) { snap(r); return; }
                    }
                }
            }
        }

        function snap(nearRow) {
            let bestRow = nearRow, bestCol = 0, bestDist = Infinity;

            for (let r = Math.max(0, nearRow - 1); r <= nearRow + 1; r++) {
                const offset = r % 2 === 0 ? 0 : SNOOD_RADIUS;
                const maxC = COLS - (r % 2);
                for (let c = 0; c <= maxC; c++) {
                    const x = c * SNOOD_RADIUS * 2 + SNOOD_RADIUS + offset;
                    const y = r * ROW_HEIGHT + SNOOD_RADIUS + 20;
                    if (!grid[r]) grid[r] = [];
                    if (grid[r][c]) continue;
                    const dx = shootingSnood.x - x, dy = shootingSnood.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < bestDist) { bestDist = dist; bestRow = r; bestCol = c; }
                }
            }

            if (!grid[bestRow]) grid[bestRow] = [];
            const offset = bestRow % 2 === 0 ? 0 : SNOOD_RADIUS;
            grid[bestRow][bestCol] = {
                type: shootingSnood.type,
                x: bestCol * SNOOD_RADIUS * 2 + SNOOD_RADIUS + offset,
                y: bestRow * ROW_HEIGHT + SNOOD_RADIUS + 20
            };
            shootingSnood = null;
            checkMatches(bestRow, bestCol);
        }

        function checkMatches(row, col) {
            const type = grid[row][col].type;
            const matches = [], visited = new Set();

            function flood(r, c) {
                const key = `${r},${c}`;
                if (visited.has(key) || !grid[r]?.[c] || grid[r][c].type !== type) return;
                visited.add(key);
                matches.push({ r, c });
                const odd = r % 2 === 1;
                const neighbors = odd ? [[r-1,c],[r-1,c+1],[r,c-1],[r,c+1],[r+1,c],[r+1,c+1]] : [[r-1,c-1],[r-1,c],[r,c-1],[r,c+1],[r+1,c-1],[r+1,c]];
                neighbors.forEach(([nr, nc]) => flood(nr, nc));
            }

            flood(row, col);

            if (matches.length >= 3) {
                animating = true;
                matches.forEach(m => {
                    const s = grid[m.r][m.c];
                    createParticle(s.x, s.y, SNOOD_TYPES[s.type].emoji);
                    grid[m.r][m.c] = null;
                });

                const pts = matches.length * 10 * level;
                score += pts + Math.floor(pts * (combo - 1) * 0.5);
                totalCleared += matches.length;

                if (combo > 1) showCombo(grid[row]?.[col]?.x || canvas.width/2, grid[row]?.[col]?.y || 200);
                combo++;
                maxCombo = Math.max(maxCombo, combo);

                setTimeout(() => {
                    removeFloating();
                    if (totalCleared >= level * 25) { level++; addRow(); }
                    animating = false;
                    updateDisplay();
                    checkGameOver();
                }, 200);
            } else {
                combo = 1;
                updateDisplay();
                checkGameOver();
            }
        }

        function removeFloating() {
            const connected = new Set();
            function mark(r, c) {
                const key = `${r},${c}`;
                if (connected.has(key) || !grid[r]?.[c]) return;
                connected.add(key);
                const odd = r % 2 === 1;
                const neighbors = odd ? [[r-1,c],[r-1,c+1],[r,c-1],[r,c+1],[r+1,c],[r+1,c+1]] : [[r-1,c-1],[r-1,c],[r,c-1],[r,c+1],[r+1,c-1],[r+1,c]];
                neighbors.forEach(([nr, nc]) => mark(nr, nc));
            }
            if (grid[0]) grid[0].forEach((s, c) => { if (s) mark(0, c); });

            let floating = 0;
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < (grid[r]?.length || 0); c++) {
                    if (grid[r][c] && !connected.has(`${r},${c}`)) {
                        createParticle(grid[r][c].x, grid[r][c].y, SNOOD_TYPES[grid[r][c].type].emoji);
                        grid[r][c] = null;
                        floating++;
                    }
                }
            }
            if (floating > 0) { score += floating * 25 * level; totalCleared += floating; }
        }

        function addRow() {
            for (let r = grid.length - 1; r >= 0; r--) {
                if (grid[r]) grid[r].forEach(s => { if (s) s.y += ROW_HEIGHT; });
            }
            grid.unshift([]);
            for (let c = 0; c < COLS; c++) {
                grid[0][c] = { type: Math.floor(Math.random() * Math.min(5 + Math.floor(level/2), SNOOD_TYPES.length)), x: c * SNOOD_RADIUS * 2 + SNOOD_RADIUS, y: SNOOD_RADIUS + 20 };
            }
            for (let r = 1; r < grid.length; r++) {
                if (grid[r]) {
                    const off = r % 2 === 0 ? 0 : SNOOD_RADIUS;
                    grid[r].forEach((s, c) => { if (s) { s.x = c * SNOOD_RADIUS * 2 + SNOOD_RADIUS + off; s.y = r * ROW_HEIGHT + SNOOD_RADIUS + 20; } });
                }
            }
        }

        function checkGameOver() {
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < (grid[r]?.length || 0); c++) {
                    if (grid[r][c] && grid[r][c].y > DANGER_LINE) { endGame(); return; }
                }
            }
            let has = false;
            for (let r = 0; r < grid.length && !has; r++) for (let c = 0; c < (grid[r]?.length || 0) && !has; c++) if (grid[r][c]) has = true;
            if (!has) { score += 500 * level; level++; resetGame(); }
        }

        function endGame() {
            gameOver = true; gameStarted = false;
            document.getElementById('gameOverTitle').textContent = 'MANAGEMENT WINS';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalCombo').textContent = maxCombo;
            document.getElementById('finalCleared').textContent = totalCleared;
            const isHigh = saveScore();
            document.getElementById('newHighScore').classList.toggle('hidden', !isHigh);
            gameOverOverlay.classList.remove('hidden');
        }

        function createParticle(x, y, emoji) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.textContent = emoji;
            p.style.left = (canvas.offsetLeft + x) + 'px';
            p.style.top = (canvas.offsetTop + y) + 'px';
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 2000);
        }

        function showCombo(x, y) {
            const c = document.createElement('div');
            c.className = 'combo-popup';
            c.textContent = combo + 'x COMBO!';
            c.style.left = (canvas.offsetLeft + x) + 'px';
            c.style.top = (canvas.offsetTop + y) + 'px';
            document.body.appendChild(c);
            setTimeout(() => c.remove(), 1000);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Danger zone with animated glow
            const dangerPulse = 0.1 + Math.sin(Date.now() / 300) * 0.05;
            ctx.fillStyle = `rgba(255,0,0,${dangerPulse})`;
            ctx.fillRect(0, DANGER_LINE, canvas.width, canvas.height - DANGER_LINE);
            
            // Danger line with glow effect
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(0, DANGER_LINE);
            ctx.lineTo(canvas.width, DANGER_LINE);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            // Draw grid snoods
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < (grid[r]?.length || 0); c++) {
                    const s = grid[r][c];
                    if (s) drawSnood(s.x, s.y, s.type);
                }
            }

            if (shootingSnood) drawSnood(shootingSnood.x, shootingSnood.y, shootingSnood.type, 1, true);

            if (currentSnood && !shootingSnood && !gameOver) {
                // Draw launcher base platform
                drawLauncherBase();
                
                // Draw aim trajectory with dots
                drawAimTrajectory(currentSnood.x, currentSnood.y, aimAngle);
                
                // Draw launcher cannon
                drawLauncherCannon(currentSnood.x, currentSnood.y, aimAngle);
                
                // Draw current snood in launcher
                drawSnood(currentSnood.x, currentSnood.y, currentSnood.type, 1, true);

                // Next snood preview
                ctx.fillStyle = '#888';
                ctx.font = '14px VT323';
                ctx.textAlign = 'center';
                ctx.fillText('NEXT', canvas.width - 40, canvas.height - 60);
                drawNextSnoodPreview(canvas.width - 40, canvas.height - 32, nextSnood.type);
            }
        }

        function drawLauncherBase() {
            const baseY = canvas.height - 15;
            const baseWidth = 120;
            const baseHeight = 20;
            const centerX = canvas.width / 2;
            
            // Platform shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.ellipse(centerX, baseY + 5, baseWidth/2 + 5, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Metal platform base
            const baseGrad = ctx.createLinearGradient(centerX - baseWidth/2, baseY - baseHeight, centerX + baseWidth/2, baseY);
            baseGrad.addColorStop(0, '#2a2a3a');
            baseGrad.addColorStop(0.3, '#4a4a5a');
            baseGrad.addColorStop(0.5, '#5a5a6a');
            baseGrad.addColorStop(0.7, '#4a4a5a');
            baseGrad.addColorStop(1, '#2a2a3a');
            
            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.moveTo(centerX - baseWidth/2, baseY);
            ctx.lineTo(centerX - baseWidth/2 + 15, baseY - baseHeight);
            ctx.lineTo(centerX + baseWidth/2 - 15, baseY - baseHeight);
            ctx.lineTo(centerX + baseWidth/2, baseY);
            ctx.closePath();
            ctx.fill();
            
            // Platform edge highlight
            ctx.strokeStyle = '#6a6a7a';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Decorative rivets
            ctx.fillStyle = '#888';
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.arc(centerX + i * 20, baseY - 8, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLauncherCannon(x, y, angle) {
            const cannonLength = 50;
            const cannonWidth = 28;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI/2);
            
            // Cannon shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(3, 0, cannonWidth/2 + 2, cannonWidth/2 + 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Cannon barrel gradient
            const barrelGrad = ctx.createLinearGradient(-cannonWidth/2, 0, cannonWidth/2, 0);
            barrelGrad.addColorStop(0, '#3a3a4a');
            barrelGrad.addColorStop(0.2, '#5a5a6a');
            barrelGrad.addColorStop(0.5, '#6a6a7a');
            barrelGrad.addColorStop(0.8, '#5a5a6a');
            barrelGrad.addColorStop(1, '#3a3a4a');
            
            // Main barrel
            ctx.fillStyle = barrelGrad;
            ctx.beginPath();
            ctx.roundRect(-cannonWidth/2, -cannonLength + 10, cannonWidth, cannonLength, 5);
            ctx.fill();
            
            // Barrel stripes/rings
            ctx.strokeStyle = '#4a4a5a';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-cannonWidth/2, -cannonLength + 20 + i * 12);
                ctx.lineTo(cannonWidth/2, -cannonLength + 20 + i * 12);
                ctx.stroke();
            }
            
            // Cannon muzzle (opening)
            const muzzleGrad = ctx.createRadialGradient(0, -cannonLength + 10, 0, 0, -cannonLength + 10, cannonWidth/2);
            muzzleGrad.addColorStop(0, '#1a1a2a');
            muzzleGrad.addColorStop(0.7, '#2a2a3a');
            muzzleGrad.addColorStop(1, '#4a4a5a');
            ctx.fillStyle = muzzleGrad;
            ctx.beginPath();
            ctx.ellipse(0, -cannonLength + 10, cannonWidth/2 - 2, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Base mounting ring
            const ringGrad = ctx.createRadialGradient(0, 5, 0, 0, 5, 22);
            ringGrad.addColorStop(0, '#5a5a6a');
            ringGrad.addColorStop(0.5, '#4a4a5a');
            ringGrad.addColorStop(1, '#3a3a4a');
            ctx.fillStyle = ringGrad;
            ctx.beginPath();
            ctx.arc(0, 5, 22, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#6a6a7a';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Inner ring highlight
            ctx.strokeStyle = '#7a7a8a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 5, 18, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawAimTrajectory(x, y, angle) {
            const maxDist = 400;
            const dotCount = 20;
            const dotSpacing = maxDist / dotCount;
            
            for (let i = 1; i <= dotCount; i++) {
                const dist = i * dotSpacing;
                const dotX = x + Math.cos(angle) * dist;
                const dotY = y + Math.sin(angle) * dist;
                
                // Stop if out of bounds
                if (dotY < 0 || dotX < 0 || dotX > canvas.width) break;
                
                const alpha = 1 - (i / dotCount) * 0.8;
                const size = 4 - (i / dotCount) * 2;
                
                // Glowing dot
                ctx.shadowColor = '#00ffaa';
                ctx.shadowBlur = 8;
                ctx.fillStyle = `rgba(0, 255, 170, ${alpha})`;
                ctx.beginPath();
                ctx.arc(dotX, dotY, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawNextSnoodPreview(x, y, type) {
            const t = SNOOD_TYPES[type], r = SNOOD_RADIUS * 0.7;
            
            // Preview box
            ctx.fillStyle = 'rgba(20,20,40,0.8)';
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x - 25, y - 25, 50, 50, 8);
            ctx.fill();
            ctx.stroke();
            
            // Snood with glow
            ctx.shadowColor = t.color;
            ctx.shadowBlur = 10;
            
            const g = ctx.createRadialGradient(x - r*0.3, y - r*0.3, 0, x, y, r);
            g.addColorStop(0, '#ffffff');
            g.addColorStop(0.3, t.color);
            g.addColorStop(1, shadeColor(t.color, -40));
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = shadeColor(t.color, -60);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = `${Math.floor(r * 1.1)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.emoji, x, y + 1);
        }

        function drawSnood(x, y, type, scale = 1, glow = false) {
            const t = SNOOD_TYPES[type], r = SNOOD_RADIUS * scale;
            
            // Outer glow effect
            if (glow) {
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 15;
            }
            
            // Main sphere gradient
            const g = ctx.createRadialGradient(x - r*0.3, y - r*0.3, 0, x, y, r);
            g.addColorStop(0, '#ffffff');
            g.addColorStop(0.2, lightenColor(t.color, 30));
            g.addColorStop(0.5, t.color);
            g.addColorStop(1, shadeColor(t.color, -50));
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Outer ring
            ctx.strokeStyle = shadeColor(t.color, -60);
            ctx.lineWidth = 2 * scale;
            ctx.stroke();
            
            // Inner highlight arc
            ctx.strokeStyle = `rgba(255,255,255,0.4)`;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(x - r*0.2, y - r*0.2, r * 0.6, Math.PI * 1.2, Math.PI * 1.8);
            ctx.stroke();
            
            // Emoji with slight shadow
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.font = `${Math.floor(r * 1.2)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.emoji, x, y + 1);
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        function lightenColor(c, p) {
            const n = parseInt(c.replace('#', ''), 16);
            const R = Math.min(255, (n >> 16) + p);
            const G = Math.min(255, ((n >> 8) & 0xFF) + p);
            const B = Math.min(255, (n & 0xFF) + p);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function shadeColor(c, p) {
            const n = parseInt(c.replace('#', ''), 16), a = Math.round(2.55 * p);
            const R = Math.max(0, Math.min(255, (n >> 16) + a));
            const G = Math.max(0, Math.min(255, ((n >> 8) & 0xFF) + a));
            const B = Math.max(0, Math.min(255, (n & 0xFF) + a));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function gameLoop() {
            if (!gameStarted) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.getElementById('startGameBtn').addEventListener('click', startGame);
        playerNameInput.addEventListener('keypress', e => { if (e.key === 'Enter') startGame(); });
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            gameOverOverlay.classList.add('hidden');
            resetGame();
            gameStarted = true;
            gameLoop();
        });
        document.getElementById('changeNameBtn').addEventListener('click', () => {
            gameOverOverlay.classList.add('hidden');
            nameOverlay.classList.remove('hidden');
            playerNameInput.focus();
        });
        document.getElementById('clearScoresBtn').addEventListener('click', () => {
            if (confirm('Clear all scores?')) {
                leaderboard = [];
                localStorage.removeItem('snoodLeaderboard');
                updateLeaderboardDisplay();
                updateHighScoreDisplay();
            }
        });
        document.getElementById('shareScoreBtn').addEventListener('click', () => {
            const shareText = `SNOOD SINDICAL - Union Game Results

Player: ${playerName}
Score: ${score}
Level: ${level}
Max Combo: ${maxCombo}x
Snoods Cleared: ${totalCleared}

The revolution will not be televised, but your score will be shared!

Play now: https://ables.ai/snood.html`;
            
            navigator.clipboard.writeText(shareText).then(() => {
                const copied = document.getElementById('shareCopied');
                copied.classList.remove('hidden');
                setTimeout(() => copied.classList.add('hidden'), 2000);
            }).catch(() => {
                alert('Copy failed. Share this:\n\n' + shareText);
            });
        });

        init();
    </script>
</body>
</html>
