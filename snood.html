<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNOOD SINDICAL - Official Union Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'VT323', monospace;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(120, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(0, 200, 255, 0.1) 0%, transparent 50%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,0.01) 2px, rgba(255,255,255,0.01) 4px);
            pointer-events: none;
            z-index: -1;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .main-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 48px;
            color: #00ff88;
            text-shadow: 
                0 0 10px #00ff88,
                0 0 20px #00ff88,
                0 0 40px #00ff88,
                4px 4px 0 #005533;
            margin-bottom: 20px;
            letter-spacing: 8px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 40px #00ff88, 4px 4px 0 #005533; }
            to { text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88, 0 0 60px #00ff88, 4px 4px 0 #005533; }
        }

        .game-frame {
            border: 4px solid #333;
            border-radius: 8px;
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            box-shadow: 
                0 0 0 2px #00ff88,
                0 0 30px rgba(0, 255, 136, 0.3),
                inset 0 0 60px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .side-panel {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 20px;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .stat-box {
            margin-bottom: 20px;
            text-align: center;
        }

        .stat-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        .stat-value {
            font-size: 36px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        .level-value {
            color: #ff6b6b;
            text-shadow: 0 0 10px #ff6b6b;
        }

        .next-snood {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }

        .next-preview {
            width: 60px;
            height: 60px;
            margin: 10px auto;
            border-radius: 50%;
            border: 2px solid #00ff88;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            background: rgba(0, 0, 0, 0.3);
        }

        .controls-info {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
            font-size: 14px;
            color: #666;
            line-height: 1.8;
        }

        .controls-info span {
            color: #00ff88;
        }

        .game-over-screen, .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .game-over-screen.hidden, .start-screen.hidden {
            display: none;
        }

        .game-over-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 32px;
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff6b6b;
            margin-bottom: 20px;
        }

        .win-text {
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
        }

        .final-score {
            font-size: 24px;
            color: #fff;
            margin-bottom: 30px;
        }

        .btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 15px 30px;
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            background: #00ff88;
            color: #0a0a0f;
            box-shadow: 0 0 30px #00ff88;
        }

        .danger-zone {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 0;
            height: 4px;
            background: repeating-linear-gradient(
                90deg,
                #ff0000,
                #ff0000 10px,
                #ffff00 10px,
                #ffff00 20px
            );
            opacity: 0.8;
            animation: dangerPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes dangerPulse {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }

        .logo {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #333;
            letter-spacing: 2px;
        }

        .logo span {
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    
    <div class="game-container">
        <div class="main-panel">
            <h1>SNOOD SINDICAL</h1>
            <p style="color: #ff6b6b; font-family: 'Press Start 2P', cursive; font-size: 8px; margin-bottom: 15px; letter-spacing: 2px;">‚úä OFFICIAL GAME OF THE UNION ‚úä</p>
            <div class="game-frame">
                <canvas id="gameCanvas" width="480" height="600"></canvas>
                <div class="danger-zone"></div>
                
                <div class="start-screen" id="startScreen">
                    <div class="game-over-text win-text">SNOOD SINDICAL</div>
                    <p style="color: #ff6b6b; margin-bottom: 10px; font-size: 14px;">‚úä OFFICIAL UNION APPROVED ‚úä</p>
                    <p style="color: #888; margin-bottom: 30px; font-size: 18px;">Match 3+ Snoods to overthrow management!</p>
                    <button class="btn" onclick="startGame()">¬°VIVA LA REVOLUCI√ìN!</button>
                </div>
                
                <div class="game-over-screen hidden" id="gameOverScreen">
                    <div class="game-over-text" id="endTitle">MANAGEMENT WINS</div>
                    <div class="final-score">Score: <span id="finalScore">0</span></div>
                    <button class="btn" onclick="startGame()">¬°OTRA VEZ!</button>
                </div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="stat-box">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value level-value" id="level">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">SHOTS</div>
                <div class="stat-value" id="shots">0</div>
            </div>
            <div class="next-snood">
                <div class="stat-label">NEXT</div>
                <div class="next-preview" id="nextPreview"></div>
            </div>
            <div class="controls-info">
                <span>MOUSE</span> - Aim<br>
                <span>CLICK</span> - Shoot<br>
                <span>SPACE</span> - Swap Snood
            </div>
        </div>
    </div>
    
    <div class="logo">PROPERTY OF <span>LOS UNION</span> ‚úä</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const COLS = 12;
        const ROWS = 15;
        const SNOOD_RADIUS = 18;
        const SNOOD_DIAMETER = SNOOD_RADIUS * 2;
        const SHOOTER_Y = canvas.height - 50;
        const DANGER_Y = canvas.height - 80;
        
        // Snood types with faces - UNION EDITION
        const SNOOD_TYPES = [
            { color: '#ff0000', face: '‚úä', name: 'Fist' },        // Red Fist
            { color: '#00dd00', face: 'üí∞', name: 'Money' },       // Money (demands)
            { color: '#ffff00', face: '‚ö†Ô∏è', name: 'Warning' },     // Warning
            { color: '#0088ff', face: 'üì¢', name: 'Megaphone' },   // Megaphone
            { color: '#ff8800', face: 'üî•', name: 'Fire' },        // Fire
            { color: '#dd00ff', face: '‚öîÔ∏è', name: 'Swords' },      // Revolution
            { color: '#ff0099', face: '‚òï', name: 'Coffee' },      // Coffee demands
            { color: '#00ffff', face: 'ü§ñ', name: 'Robot' }        // Sophia
        ];
        
        // Game state
        let grid = [];
        let currentSnood = null;
        let nextSnood = null;
        let shootingSnood = null;
        let aimAngle = -Math.PI / 2;
        let score = 0;
        let level = 1;
        let shots = 0;
        let gameRunning = false;
        let rowOffset = 0;
        let shotsUntilDrop = 8;
        
        function getGridX(col, row) {
            const offset = (row % 2 === 0) ? 0 : SNOOD_RADIUS;
            return col * SNOOD_DIAMETER + SNOOD_RADIUS + offset + 12;
        }
        
        function getGridY(row) {
            return row * (SNOOD_DIAMETER - 4) + SNOOD_RADIUS + rowOffset + 10;
        }
        
        function initGrid() {
            grid = [];
            const initialRows = 5 + Math.min(level - 1, 3);
            const typesInUse = Math.min(4 + level, SNOOD_TYPES.length);
            
            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                const cols = (row % 2 === 0) ? COLS : COLS - 1;
                for (let col = 0; col < cols; col++) {
                    if (row < initialRows) {
                        grid[row][col] = Math.floor(Math.random() * typesInUse);
                    } else {
                        grid[row][col] = -1;
                    }
                }
            }
        }
        
        function getRandomSnoodType() {
            const typesInUse = Math.min(4 + level, SNOOD_TYPES.length);
            return Math.floor(Math.random() * typesInUse);
        }
        
        function drawSnood(x, y, type, scale = 1) {
            const snood = SNOOD_TYPES[type];
            const r = SNOOD_RADIUS * scale;
            
            // Glow effect
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, r * 1.5);
            gradient.addColorStop(0, snood.color);
            gradient.addColorStop(0.7, snood.color);
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.arc(x, y, r * 1.2, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.3;
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Main circle
            const innerGradient = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
            innerGradient.addColorStop(0, lightenColor(snood.color, 40));
            innerGradient.addColorStop(0.7, snood.color);
            innerGradient.addColorStop(1, darkenColor(snood.color, 30));
            
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = innerGradient;
            ctx.fill();
            
            // Border
            ctx.strokeStyle = darkenColor(snood.color, 50);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Face
            ctx.font = `${Math.floor(r * 1.2)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(snood.face, x, y + 1);
        }
        
        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return `rgb(${R},${G},${B})`;
        }
        
        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return `rgb(${R},${G},${B})`;
        }
        
        function drawGrid() {
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col] >= 0) {
                        const x = getGridX(col, row);
                        const y = getGridY(row);
                        drawSnood(x, y, grid[row][col]);
                    }
                }
            }
        }
        
        function drawShooter() {
            const centerX = canvas.width / 2;
            
            // Draw aiming line
            ctx.beginPath();
            ctx.moveTo(centerX, SHOOTER_Y);
            const lineLength = 100;
            const endX = centerX + Math.cos(aimAngle) * lineLength;
            const endY = SHOOTER_Y + Math.sin(aimAngle) * lineLength;
            
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
            ctx.lineWidth = 2;
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw dotted trajectory
            let simX = centerX;
            let simY = SHOOTER_Y;
            let simDX = Math.cos(aimAngle) * 8;
            let simDY = Math.sin(aimAngle) * 8;
            
            ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
            for (let i = 0; i < 30; i++) {
                simX += simDX;
                simY += simDY;
                
                if (simX < SNOOD_RADIUS || simX > canvas.width - SNOOD_RADIUS) {
                    simDX = -simDX;
                }
                if (simY < 0) break;
                
                if (i % 3 === 0) {
                    ctx.beginPath();
                    ctx.arc(simX, simY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw current snood
            if (currentSnood !== null) {
                drawSnood(centerX, SHOOTER_Y, currentSnood, 1.1);
            }
            
            // Draw launcher base
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(centerX, SHOOTER_Y + 20, 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawShootingSnood() {
            if (shootingSnood) {
                drawSnood(shootingSnood.x, shootingSnood.y, shootingSnood.type);
            }
        }
        
        function shoot() {
            if (shootingSnood || currentSnood === null || !gameRunning) return;
            
            const centerX = canvas.width / 2;
            shootingSnood = {
                x: centerX,
                y: SHOOTER_Y,
                dx: Math.cos(aimAngle) * 12,
                dy: Math.sin(aimAngle) * 12,
                type: currentSnood
            };
            
            currentSnood = nextSnood;
            nextSnood = getRandomSnoodType();
            updateNextPreview();
            shots++;
            document.getElementById('shots').textContent = shots;
            
            shotsUntilDrop--;
            if (shotsUntilDrop <= 0) {
                dropCeiling();
                shotsUntilDrop = Math.max(5, 10 - level);
            }
        }
        
        function swapSnoods() {
            if (shootingSnood || !gameRunning) return;
            const temp = currentSnood;
            currentSnood = nextSnood;
            nextSnood = temp;
            updateNextPreview();
        }
        
        function updateNextPreview() {
            const preview = document.getElementById('nextPreview');
            if (nextSnood !== null) {
                preview.textContent = SNOOD_TYPES[nextSnood].face;
                preview.style.background = SNOOD_TYPES[nextSnood].color + '33';
            }
        }
        
        function updateShootingSnood() {
            if (!shootingSnood) return;
            
            shootingSnood.x += shootingSnood.dx;
            shootingSnood.y += shootingSnood.dy;
            
            // Wall bounce
            if (shootingSnood.x < SNOOD_RADIUS) {
                shootingSnood.x = SNOOD_RADIUS;
                shootingSnood.dx = -shootingSnood.dx;
            }
            if (shootingSnood.x > canvas.width - SNOOD_RADIUS) {
                shootingSnood.x = canvas.width - SNOOD_RADIUS;
                shootingSnood.dx = -shootingSnood.dx;
            }
            
            // Ceiling hit
            if (shootingSnood.y < SNOOD_RADIUS + rowOffset + 10) {
                snapToGrid();
                return;
            }
            
            // Collision with other snoods
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col] >= 0) {
                        const gridX = getGridX(col, row);
                        const gridY = getGridY(row);
                        const dist = Math.sqrt(
                            Math.pow(shootingSnood.x - gridX, 2) + 
                            Math.pow(shootingSnood.y - gridY, 2)
                        );
                        if (dist < SNOOD_DIAMETER - 2) {
                            snapToGrid();
                            return;
                        }
                    }
                }
            }
        }
        
        function snapToGrid() {
            // Find closest empty grid position
            let bestRow = -1;
            let bestCol = -1;
            let bestDist = Infinity;
            
            for (let row = 0; row < ROWS; row++) {
                const cols = (row % 2 === 0) ? COLS : COLS - 1;
                for (let col = 0; col < cols; col++) {
                    if (grid[row][col] === -1) {
                        const gridX = getGridX(col, row);
                        const gridY = getGridY(row);
                        const dist = Math.sqrt(
                            Math.pow(shootingSnood.x - gridX, 2) + 
                            Math.pow(shootingSnood.y - gridY, 2)
                        );
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestRow = row;
                            bestCol = col;
                        }
                    }
                }
            }
            
            if (bestRow >= 0 && bestCol >= 0) {
                grid[bestRow][bestCol] = shootingSnood.type;
                
                // Check for matches
                const matches = findMatches(bestRow, bestCol);
                if (matches.length >= 3) {
                    // Remove matches
                    for (const match of matches) {
                        grid[match.row][match.col] = -1;
                    }
                    score += matches.length * 10 * level;
                    
                    // Remove floating snoods
                    const floating = findFloatingSnoods();
                    for (const f of floating) {
                        grid[f.row][f.col] = -1;
                    }
                    score += floating.length * 20 * level;
                    
                    document.getElementById('score').textContent = score;
                    
                    // Check for win
                    if (isGridEmpty()) {
                        levelUp();
                    }
                }
                
                // Check for game over
                if (getGridY(bestRow) > DANGER_Y - SNOOD_RADIUS) {
                    gameOver(false);
                }
            }
            
            shootingSnood = null;
        }
        
        function findMatches(startRow, startCol) {
            const type = grid[startRow][startCol];
            const matches = [];
            const visited = new Set();
            
            function flood(row, col) {
                const key = `${row},${col}`;
                if (visited.has(key)) return;
                if (row < 0 || row >= grid.length) return;
                if (col < 0 || col >= grid[row].length) return;
                if (grid[row][col] !== type) return;
                
                visited.add(key);
                matches.push({ row, col });
                
                // Get neighbors
                const neighbors = getNeighbors(row, col);
                for (const n of neighbors) {
                    flood(n.row, n.col);
                }
            }
            
            flood(startRow, startCol);
            return matches;
        }
        
        function getNeighbors(row, col) {
            const neighbors = [];
            const isEvenRow = row % 2 === 0;
            
            // Same row
            neighbors.push({ row, col: col - 1 });
            neighbors.push({ row, col: col + 1 });
            
            // Row above
            if (isEvenRow) {
                neighbors.push({ row: row - 1, col: col - 1 });
                neighbors.push({ row: row - 1, col });
            } else {
                neighbors.push({ row: row - 1, col });
                neighbors.push({ row: row - 1, col: col + 1 });
            }
            
            // Row below
            if (isEvenRow) {
                neighbors.push({ row: row + 1, col: col - 1 });
                neighbors.push({ row: row + 1, col });
            } else {
                neighbors.push({ row: row + 1, col });
                neighbors.push({ row: row + 1, col: col + 1 });
            }
            
            return neighbors.filter(n => 
                n.row >= 0 && n.row < grid.length && 
                n.col >= 0 && n.col < grid[n.row].length
            );
        }
        
        function findFloatingSnoods() {
            const connected = new Set();
            
            // BFS from top row
            function markConnected(row, col) {
                const queue = [{ row, col }];
                while (queue.length > 0) {
                    const { row, col } = queue.shift();
                    const key = `${row},${col}`;
                    if (connected.has(key)) continue;
                    if (row < 0 || row >= grid.length) continue;
                    if (col < 0 || col >= grid[row].length) continue;
                    if (grid[row][col] < 0) continue;
                    
                    connected.add(key);
                    const neighbors = getNeighbors(row, col);
                    for (const n of neighbors) {
                        queue.push(n);
                    }
                }
            }
            
            // Mark all snoods connected to top row
            for (let col = 0; col < grid[0].length; col++) {
                if (grid[0][col] >= 0) {
                    markConnected(0, col);
                }
            }
            
            // Find floating snoods
            const floating = [];
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col] >= 0 && !connected.has(`${row},${col}`)) {
                        floating.push({ row, col });
                    }
                }
            }
            
            return floating;
        }
        
        function isGridEmpty() {
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col] >= 0) return false;
                }
            }
            return true;
        }
        
        function dropCeiling() {
            rowOffset += 20;
            
            // Check if any snood is now in danger zone
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col] >= 0) {
                        const y = getGridY(row);
                        if (y > DANGER_Y - SNOOD_RADIUS) {
                            gameOver(false);
                            return;
                        }
                    }
                }
            }
        }
        
        function levelUp() {
            level++;
            document.getElementById('level').textContent = level;
            rowOffset = 0;
            shotsUntilDrop = Math.max(5, 10 - level);
            initGrid();
            currentSnood = getRandomSnoodType();
            nextSnood = getRandomSnoodType();
            updateNextPreview();
        }
        
        function gameOver(won) {
            gameRunning = false;
            const screen = document.getElementById('gameOverScreen');
            const title = document.getElementById('endTitle');
            document.getElementById('finalScore').textContent = score;
            
            if (won) {
                title.textContent = '¬°VICTORIA!';
                title.className = 'game-over-text win-text';
            } else {
                title.textContent = 'MANAGEMENT WINS';
                title.className = 'game-over-text';
            }
            
            screen.classList.remove('hidden');
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            score = 0;
            level = 1;
            shots = 0;
            rowOffset = 0;
            shotsUntilDrop = 8;
            
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('shots').textContent = shots;
            
            initGrid();
            currentSnood = getRandomSnoodType();
            nextSnood = getRandomSnoodType();
            updateNextPreview();
            gameRunning = true;
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw gradient background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#1a1a2e');
            bgGradient.addColorStop(1, '#0d1117');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawShootingSnood();
            drawShooter();
        }
        
        function gameLoop() {
            if (gameRunning) {
                updateShootingSnood();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const centerX = canvas.width / 2;
            
            aimAngle = Math.atan2(mouseY - SHOOTER_Y, mouseX - centerX);
            // Limit angle to upward directions
            if (aimAngle > -0.1) aimAngle = -0.1;
            if (aimAngle < -Math.PI + 0.1) aimAngle = -Math.PI + 0.1;
        });
        
        canvas.addEventListener('click', shoot);
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                swapSnoods();
            }
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
