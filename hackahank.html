<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HACK A' HANK | Sutton Funding</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Cormorant+Garamond:wght@400;600&family=Jost:wght@300;400;500&display=swap');

        :root {
            /* Sutton Funding Brand Colors */
            --sf-navy: #001A32;
            --sf-navy-dark: #000d19;
            --sf-navy-light: #1f2937;
            --sf-ivory: #FAF8F3;
            --sf-ivory-dark: #EBE6DA;
            --sf-ivory-light: #FDFCF9;
            --sf-brass: #A39171;
            --sf-brass-light: #c4b08a;
            --sf-brass-dark: #8B7355;
            --sf-slate: #374151;

            /* Accent colors */
            --sf-gold: #d4aa00;
            --sf-red: #8b0000;
            --sf-success: #2d5a2d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: var(--sf-ivory);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Bangers', cursive;
            overflow: hidden;
            letter-spacing: 1px;
            position: relative;
        }

        /* Subtle linen texture */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h1v1H0V0zm2 0h1v1H2V0zm2 0h1v1H4V0zm2 0h1v1H6V0zm2 0h1v1H8V0zm2 0h1v1h-1V0zm2 0h1v1h-1V0zm2 0h1v1h-1V0zm2 0h1v1h-1V0zm2 0h1v1h-1V0z' fill='%23A39171' fill-opacity='0.03'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 0;
        }

        /* Screen effects */
        .shake { animation: shake 0.2s ease-out; }
        @keyframes shake {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-8px, 4px); }
            40% { transform: translate(8px, -4px); }
            60% { transform: translate(-4px, 8px); }
            80% { transform: translate(4px, -8px); }
        }

        #hitFlash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
        }

        #hitFlash.red {
            background: radial-gradient(circle, rgba(255,50,50,0.7) 0%, rgba(255,0,0,0.3) 40%, transparent 70%);
            opacity: 1;
            animation: flashRed 0.25s ease-out;
        }
        #hitFlash.gold {
            background: radial-gradient(circle, rgba(255,230,100,0.8) 0%, rgba(255,215,0,0.4) 40%, transparent 70%);
            opacity: 1;
            animation: flashGold 0.4s ease-out;
        }
        #hitFlash.hurt {
            background: linear-gradient(45deg, rgba(255,0,0,0.6) 0%, rgba(150,0,0,0.4) 100%);
            opacity: 1;
            animation: flashHurt 0.5s ease-out;
        }
        @keyframes flashRed {
            0% { opacity: 1; transform: scale(0.8); }
            50% { opacity: 0.8; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1); }
        }
        @keyframes flashGold {
            0% { opacity: 1; filter: brightness(1.5); }
            100% { opacity: 0; filter: brightness(1); }
        }
        @keyframes flashHurt {
            0% { opacity: 1; }
            20% { opacity: 0.3; }
            40% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        /* Scanlines overlay for retro feel */
        #scanlines {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.03) 0px,
                rgba(0,0,0,0.03) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 998;
        }

        /* Vignette effect */
        #vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,26,50,0.3) 100%);
            pointer-events: none;
            z-index: 997;
        }

        /* Score popup fly effect */
        @keyframes scoreFly {
            0% { transform: translate(-50%, 0) scale(0.5) rotate(-10deg); opacity: 1; }
            30% { transform: translate(-50%, -20px) scale(1.3) rotate(5deg); opacity: 1; }
            100% { transform: translate(-50%, -80px) scale(0.8) rotate(0); opacity: 0; }
        }

        #gameContainer {
            width: 100%;
            max-width: 600px;
            padding: 10px;
        }

        /* Sutton Funding Logo */
        #sfLogo {
            position: fixed;
            top: 15px;
            left: 15px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--sf-navy);
            letter-spacing: 0.05em;
            z-index: 100;
        }

        /* Title - Elegant Sutton Style */
        #title {
            font-size: 2.8rem;
            text-align: center;
            color: var(--sf-navy);
            text-shadow: 2px 2px 0 var(--sf-brass-light);
            margin: 15px 0 10px 0;
        }

        /* HUD - Elegant Sutton Navy with Brass accents */
        #hud {
            display: flex;
            justify-content: space-between;
            background: var(--sf-navy);
            border: 1px solid var(--sf-brass);
            border-radius: 4px;
            padding: 12px 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0,26,50,0.3);
        }

        .hud-item { text-align: center; }
        .hud-label {
            font-size: 0.65rem;
            color: var(--sf-brass);
            font-family: 'Jost', sans-serif;
            font-weight: 400;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        .hud-value {
            font-size: 1.5rem;
            color: var(--sf-ivory);
            font-family: 'Cormorant Garamond', serif;
        }
        #timerValue { color: var(--sf-brass-light); }
        #timerValue.danger { color: #ff4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; transform: scale(1.1); } }

        /* Weapon Bar - Sutton Elegant Style */
        #weaponBar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .weapon-btn {
            flex: 1;
            padding: 10px 5px;
            background: var(--sf-ivory-light);
            border: 1px solid var(--sf-ivory-dark);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .weapon-btn:hover {
            border-color: var(--sf-brass);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .weapon-btn.selected {
            background: var(--sf-navy);
            border-color: var(--sf-brass);
            box-shadow: 0 4px 15px rgba(0,26,50,0.3);
        }
        .weapon-btn.selected .icon { filter: grayscale(0); }
        .weapon-btn.selected .name { color: var(--sf-brass-light); }

        .weapon-btn .icon { font-size: 1.8rem; }
        .weapon-btn .name {
            font-size: 0.6rem;
            color: var(--sf-slate);
            font-family: 'Jost', sans-serif;
            font-weight: 400;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        /* Game Board - Elegant Sutton Style */
        #gameBoard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            background: var(--sf-navy);
            border: 1px solid var(--sf-brass);
            border-radius: 6px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,26,50,0.4),
                        inset 0 0 30px rgba(0,0,0,0.3);
            aspect-ratio: 1;
        }

        .hole {
            position: relative;
            background: radial-gradient(ellipse at center bottom, #000d19 0%, #001A32 60%, #0a2a45 100%);
            border-radius: 15px;
            overflow: hidden;
            cursor: crosshair;
        }

        /* Hole depth effect */
        .hole::before {
            content: '';
            position: absolute;
            bottom: 0; left: 5%; width: 90%; height: 30%;
            background: radial-gradient(ellipse at center, #000 50%, transparent 100%);
            border-radius: 50%;
        }

        /* Hank container */
        .hank-wrap {
            position: absolute;
            bottom: -100%;
            left: 5%; width: 90%; height: 95%;
            transition: bottom 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1;
        }

        .hank-wrap.up { bottom: 8%; }

        /* Animations */
        .hank-wrap.idle { animation: idle 0.8s ease-in-out infinite; }
        @keyframes idle {
            0%, 100% { transform: translateY(0) rotate(-1deg); }
            50% { transform: translateY(-4px) rotate(1deg); }
        }

        .hank-wrap.laughing { animation: laugh 0.1s ease-in-out infinite; }
        @keyframes laugh {
            0%, 100% { transform: translateY(0) rotate(-3deg) scale(1.02); }
            50% { transform: translateY(-6px) rotate(3deg) scale(1.05); }
        }

        .hank-wrap.hit { animation: hit 0.5s ease-out forwards; }
        @keyframes hit {
            0% { transform: scale(1) rotate(0); filter: brightness(1); }
            10% { transform: scale(1.3) rotate(-15deg); filter: brightness(3) saturate(2); }
            30% { transform: scale(1.1) rotate(10deg); filter: brightness(2); }
            50% { transform: scale(0.9) rotate(25deg); filter: brightness(1.5); }
            100% { transform: scale(0.3) rotate(45deg) translateY(80px); opacity: 0; filter: brightness(0.5); }
        }

        .hank-wrap.taunting { animation: taunt 0.25s ease-in-out infinite; }
        @keyframes taunt {
            0%, 100% { transform: rotate(-8deg) scale(1.02); }
            50% { transform: rotate(8deg) scale(1.05); }
        }

        /* Pop-up entrance animation */
        .hank-wrap.entering { animation: popUp 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        @keyframes popUp {
            0% { transform: translateY(100%) scale(0.5); }
            60% { transform: translateY(-10%) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        /* Type effects - Enhanced with animations */
        .hank-wrap.golden svg {
            filter: drop-shadow(0 0 20px #ffd700) drop-shadow(0 0 40px #ffaa00) drop-shadow(0 0 60px #ff8800);
            animation: goldenGlow 0.5s ease-in-out infinite alternate;
        }
        @keyframes goldenGlow {
            0% { filter: drop-shadow(0 0 15px #ffd700) drop-shadow(0 0 30px #ffaa00); }
            100% { filter: drop-shadow(0 0 25px #ffd700) drop-shadow(0 0 50px #ffaa00) drop-shadow(0 0 70px #ff6600); }
        }
        .hank-wrap.golden svg .suit { fill: #8b7500; }

        .hank-wrap.bomb svg {
            filter: drop-shadow(0 0 15px #ff0000) drop-shadow(0 0 30px #cc0000);
            animation: bombPulse 0.3s ease-in-out infinite;
        }
        @keyframes bombPulse {
            0%, 100% { filter: drop-shadow(0 0 10px #ff0000) drop-shadow(0 0 20px #cc0000); transform: scale(1); }
            50% { filter: drop-shadow(0 0 20px #ff3333) drop-shadow(0 0 40px #ff0000); transform: scale(1.05); }
        }

        .hank-wrap.boss svg {
            filter: drop-shadow(0 0 20px #8a2be2) drop-shadow(0 0 40px #4b0082);
            animation: bossAura 1s ease-in-out infinite;
        }
        @keyframes bossAura {
            0%, 100% { filter: drop-shadow(0 0 15px #8a2be2) drop-shadow(0 0 30px #4b0082); }
            50% { filter: drop-shadow(0 0 30px #9932cc) drop-shadow(0 0 60px #8a2be2); }
        }

        .hank-wrap.speed svg {
            filter: drop-shadow(0 0 15px #00bfff) drop-shadow(0 0 30px #0080ff);
            animation: speedBlur 0.2s linear infinite;
        }
        @keyframes speedBlur {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .hank-wrap.angry svg {
            filter: drop-shadow(0 0 12px #ff4444) hue-rotate(-10deg);
            animation: angryShake 0.1s linear infinite;
        }
        @keyframes angryShake {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }

        /* Pop-ups - Enhanced */
        .popup {
            position: fixed;
            font-size: 2.2rem;
            font-family: 'Bangers', cursive;
            font-weight: 600;
            color: var(--sf-ivory);
            text-shadow: 3px 3px 0 var(--sf-navy), -2px -2px 0 var(--sf-navy), 0 0 10px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 100;
            animation: scorePopup 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .popup.gold {
            color: #ffd700;
            font-size: 3rem;
            text-shadow: 3px 3px 0 #5a4500, 0 0 20px rgba(255,215,0,0.8), 0 0 40px rgba(255,170,0,0.5);
            animation: goldPopup 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .popup.bad {
            color: #ff4444;
            text-shadow: 2px 2px 0 #440000, 0 0 15px rgba(255,0,0,0.5);
        }
        .popup.laugh { color: var(--sf-brass); font-size: 1.8rem; }

        @keyframes scorePopup {
            0% { transform: translate(-50%, 0) scale(0) rotate(-20deg); opacity: 1; }
            40% { transform: translate(-50%, -40px) scale(1.4) rotate(10deg); opacity: 1; }
            70% { transform: translate(-50%, -60px) scale(1.1) rotate(-5deg); opacity: 0.8; }
            100% { transform: translate(-50%, -100px) scale(0.8) rotate(0); opacity: 0; }
        }

        @keyframes goldPopup {
            0% { transform: translate(-50%, 0) scale(0) rotate(-30deg); opacity: 1; filter: brightness(2); }
            30% { transform: translate(-50%, -50px) scale(1.6) rotate(15deg); opacity: 1; filter: brightness(1.5); }
            60% { transform: translate(-50%, -80px) scale(1.2) rotate(-10deg); opacity: 0.9; }
            100% { transform: translate(-50%, -120px) scale(1) rotate(0); opacity: 0; filter: brightness(1); }
        }

        /* Impact burst - Enhanced */
        .impact {
            position: fixed;
            pointer-events: none;
            z-index: 90;
            animation: impactBurst 0.5s ease-out forwards;
        }
        @keyframes impactBurst {
            0% { transform: translate(-50%, -50%) scale(0) rotate(0); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(1.5) rotate(30deg); opacity: 0.8; }
            60% { transform: translate(-50%, -50%) scale(1.8) rotate(50deg); opacity: 0.4; }
            100% { transform: translate(-50%, -50%) scale(2.2) rotate(70deg); opacity: 0; }
        }

        /* Particles - Enhanced with trails */
        .particle {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            z-index: 80;
            box-shadow: 0 0 6px currentColor, 0 0 12px currentColor;
            animation: particleFly 0.6s ease-out forwards;
        }
        @keyframes particleFly {
            to { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        /* Thrown money */
        .thrown {
            position: fixed;
            font-size: 2rem;
            pointer-events: none;
            z-index: 200;
            animation: thrown 0.6s ease-in forwards;
        }
        @keyframes thrown {
            0% { transform: scale(0.5) rotate(0); }
            100% { transform: scale(3) rotate(360deg); opacity: 0; }
        }

        /* Menus - Sutton Funding Elegant Theme */
        .menu {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--sf-ivory);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            padding: 20px;
        }
        .menu.hidden { display: none; }

        /* Elegant Title */
        .menu-title {
            font-size: 3.5rem;
            color: var(--sf-navy);
            text-shadow: 3px 3px 0 var(--sf-brass-light);
            margin-bottom: 10px;
        }

        /* Sutton Funding subtitle */
        .menu-subtitle {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            font-weight: 400;
            color: var(--sf-brass-dark);
            letter-spacing: 0.3em;
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        .menu-btn {
            padding: 15px 50px;
            font-family: 'Jost', sans-serif;
            font-weight: 400;
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--sf-ivory);
            background: var(--sf-navy);
            border: 1px solid var(--sf-brass);
            border-radius: 4px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.3s ease;
        }
        .menu-btn:hover {
            transform: scale(1.02);
            background: var(--sf-slate);
            box-shadow: 0 4px 20px rgba(0,26,50,0.3);
        }
        .menu-btn.secondary {
            background: transparent;
            color: var(--sf-slate);
            border-color: var(--sf-slate);
        }
        .menu-btn.secondary:hover {
            background: var(--sf-slate);
            color: var(--sf-ivory);
        }

        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 25px;
            width: 100%;
            max-width: 400px;
        }

        .mode-btn {
            padding: 20px;
            background: var(--sf-ivory-light);
            border: 1px solid var(--sf-ivory-dark);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            color: var(--sf-slate);
            transition: all 0.2s ease;
        }
        .mode-btn:hover {
            border-color: var(--sf-brass);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .mode-btn.selected {
            background: var(--sf-navy);
            border-color: var(--sf-brass);
            box-shadow: 0 4px 20px rgba(0,26,50,0.3);
        }
        .mode-btn.selected .name { color: var(--sf-brass-light); }
        .mode-btn .icon { font-size: 2rem; }
        .mode-btn .name {
            font-size: 1rem;
            font-family: 'Cormorant Garamond', serif;
            color: var(--sf-navy);
            margin-top: 5px;
        }

        /* Stats */
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .stat { text-align: center; }
        .stat .label {
            font-size: 0.7rem;
            color: var(--sf-brass-dark);
            font-family: 'Jost', sans-serif;
            font-weight: 400;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        .stat .value {
            font-size: 2rem;
            color: var(--sf-navy);
            font-family: 'Cormorant Garamond', serif;
        }

        /* Pause Button */
        #pauseBtn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: var(--sf-navy);
            border: 2px solid var(--sf-brass);
            border-radius: 50%;
            color: var(--sf-ivory);
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,26,50,0.4);
        }

        #pauseBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,26,50,0.5);
        }

        #pauseBtn:active {
            transform: scale(0.95);
        }

        /* Pause Menu Overlay */
        #pauseMenu {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,26,50,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #pauseMenu.show {
            display: flex;
        }

        #pauseMenu h2 {
            font-family: 'Bangers', cursive;
            font-size: 4rem;
            color: var(--sf-brass);
            text-shadow: 3px 3px 0 var(--sf-navy-dark);
            margin-bottom: 30px;
        }

        .pause-btn {
            padding: 15px 50px;
            margin: 10px;
            font-family: 'Jost', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--sf-ivory);
            background: var(--sf-brass-dark);
            border: 2px solid var(--sf-brass);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pause-btn:hover {
            background: var(--sf-brass);
            transform: scale(1.05);
        }

        /* Music toggle - Small button in corner */
        #musicToggle {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 45px;
            height: 45px;
            background: var(--sf-navy);
            border: 2px solid var(--sf-brass);
            border-radius: 50%;
            color: var(--sf-ivory);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #musicToggle:hover {
            transform: scale(1.1);
        }

        #musicToggle.off {
            opacity: 0.5;
        }

        #musicToggle.playing {
            background: var(--sf-brass-dark);
            box-shadow: 0 0 15px rgba(163,145,113,0.5);
        }

        /* Cursor */
        #cursor {
            position: fixed;
            font-size: 40px;
            pointer-events: none;
            z-index: 1000;
            transition: transform 0.05s;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
            display: none;
        }
        @media (hover: hover) {
            #cursor { display: block; }
            body { cursor: none; }
        }

        /* Health bar for boss */
        .health-bar {
            position: absolute;
            top: 5px; left: 10%; width: 80%; height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            display: none;
            z-index: 10;
        }
        .health-bar.visible { display: block; }
        .health-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.2s;
        }

        /* Combo display */
        #comboPopup {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 3.5rem;
            font-family: 'Cormorant Garamond', serif;
            color: var(--sf-brass);
            text-shadow: 3px 3px 0 var(--sf-navy), 0 0 20px rgba(163,145,113,0.5);
            pointer-events: none;
            z-index: 300;
            opacity: 0;
        }
        #comboPopup.show { animation: comboShow 0.8s ease-out; }
        @keyframes comboShow {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-20deg); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(1.5) rotate(10deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="hitFlash"></div>
    <div id="cursor">üî™</div>
    <div id="comboPopup"></div>
    <div id="sfLogo">Sutton Funding</div>
    <button id="musicToggle" onclick="toggleMusic()">üéµ</button>
    <button id="pauseBtn" onclick="togglePause()">‚è∏</button>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <button class="pause-btn" onclick="togglePause()">RESUME</button>
        <button class="pause-btn" onclick="quitToMenu()">QUIT TO MENU</button>
    </div>

    <!-- Start Menu -->
    <div id="startMenu" class="menu">
        <div class="menu-title">HACK A' HANK</div>
        <div class="menu-subtitle">Presented by Sutton Funding</div>

        <div class="mode-grid">
            <div class="mode-btn selected" data-mode="classic" onclick="selectMode('classic')">
                <div class="icon">‚è±Ô∏è</div>
                <div class="name">Classic</div>
            </div>
            <div class="mode-btn" data-mode="endless" onclick="selectMode('endless')">
                <div class="icon">‚ôæÔ∏è</div>
                <div class="name">Endless</div>
            </div>
            <div class="mode-btn" data-mode="blitz" onclick="selectMode('blitz')">
                <div class="icon">‚ö°</div>
                <div class="name">Blitz</div>
            </div>
            <div class="mode-btn" data-mode="boss" onclick="selectMode('boss')">
                <div class="icon">üëπ</div>
                <div class="name">Boss Rush</div>
            </div>
        </div>

        <button class="menu-btn" onclick="startGame()">PLAY</button>
    </div>

    <!-- Game Over -->
    <div id="gameOver" class="menu hidden">
        <div class="menu-title" style="color:#ff4444;">GAME OVER</div>

        <div class="stats">
            <div class="stat"><div class="label">SCORE</div><div class="value" id="finalScore">0</div></div>
            <div class="stat"><div class="label">HITS</div><div class="value" id="finalHits">0</div></div>
            <div class="stat"><div class="label">COMBO</div><div class="value" id="finalCombo">0x</div></div>
            <div class="stat"><div class="label">ACCURACY</div><div class="value" id="finalAcc">0%</div></div>
        </div>

        <button class="menu-btn" onclick="startGame()">PLAY AGAIN</button>
        <button class="menu-btn secondary" onclick="showMenu()">MENU</button>
    </div>

    <!-- Game -->
    <div id="gameContainer">
        <div id="title">HACK A' HANK</div>

        <div id="hud">
            <div class="hud-item"><div class="hud-label">SCORE</div><div class="hud-value" id="scoreValue">0</div></div>
            <div class="hud-item"><div class="hud-label">TIME</div><div class="hud-value" id="timerValue">60</div></div>
            <div class="hud-item"><div class="hud-label">COMBO</div><div class="hud-value" id="comboValue">0x</div></div>
            <div class="hud-item"><div class="hud-label">LIVES</div><div class="hud-value" id="livesValue">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
        </div>

        <div id="weaponBar">
            <div class="weapon-btn selected" data-w="knife" onclick="selectWeapon('knife')">
                <div class="icon">üî™</div><div class="name">Knife</div>
            </div>
            <div class="weapon-btn" data-w="axe" onclick="selectWeapon('axe')">
                <div class="icon">ü™ì</div><div class="name">Axe</div>
            </div>
            <div class="weapon-btn" data-w="hammer" onclick="selectWeapon('hammer')">
                <div class="icon">üî®</div><div class="name">Hammer</div>
            </div>
            <div class="weapon-btn" data-w="sword" onclick="selectWeapon('sword')">
                <div class="icon">‚öîÔ∏è</div><div class="name">Sword</div>
            </div>
            <div class="weapon-btn" data-w="bomb" onclick="selectWeapon('bomb')">
                <div class="icon">üí£</div><div class="name">Bomb</div>
            </div>
        </div>

        <div id="gameBoard"></div>
    </div>

    <script>
        // =====================================================
        // HANK SVG - Accurate recreation of Hank n Bank logo
        // Brown side-parted hair (parts on LEFT), yellow tie,
        // navy suit, big friendly smile, reaching handshake
        // =====================================================
        function createHankSVG(type = 'normal', expression = 'smile') {
            const isGolden = type === 'golden';
            const isBomb = type === 'bomb';
            const isBoss = type === 'boss';
            const isAngry = type === 'angry';
            const isSpeed = type === 'speed';

            // Unique IDs for this instance to prevent SVG conflicts
            const uid = Math.random().toString(36).substr(2, 9);

            // Colors - matching Hankbank.png exactly
            const skin = '#f5d5b8';
            const skinHighlight = '#ffe8d6';
            const skinShade = '#e6c4a0';
            const skinShadow = '#c9a080';

            // Brown hair - NOT auburn, NOT red - medium brown
            const hairMain = '#6b4423';
            const hairDark = '#4a2f18';
            const hairHighlight = '#8b5a2b';

            // Navy blue suit
            const suitMain = isGolden ? '#8b7500' : isBoss ? '#4a2a6a' : isAngry ? '#5a2020' : '#2b4970';
            const suitDark = isGolden ? '#6b5500' : isBoss ? '#2a1a4a' : isAngry ? '#3a1010' : '#1a3050';
            const suitHighlight = isGolden ? '#a08510' : isBoss ? '#6a4a8a' : isAngry ? '#7a3030' : '#3b5980';

            // Yellow/gold tie - this is KEY
            const tieMain = isGolden ? '#ffd700' : isBomb ? '#ff3333' : '#e8b830';
            const tieDark = isGolden ? '#daa520' : isBomb ? '#cc0000' : '#c99820';
            const tieHighlight = isGolden ? '#ffec80' : isBomb ? '#ff6666' : '#f8d860';

            const shirtColor = '#f8f8f5';
            const eyeWhite = '#ffffff';
            const eyeIris = '#5080a0';
            const eyePupil = '#1a1a1a';
            const teethColor = '#ffffff';
            const mouthDark = '#3a1515';
            const tongueColor = '#d87070';
            const lineColor = '#1a1a1a';

            // Dynamic elements based on expression
            let eyesContent = '';
            let mouthContent = '';
            let eyebrowsContent = '';
            let cheeksContent = '';
            let extraContent = '';

            if (expression === 'smile') {
                // Friendly salesman smile - eyes slightly squinted with smile
                eyesContent = `
                    <!-- Left eye -->
                    <ellipse cx="58" cy="95" rx="10" ry="8" fill="${eyeWhite}" stroke="${lineColor}" stroke-width="1.5"/>
                    <ellipse cx="60" cy="96" rx="5" ry="5" fill="${eyeIris}"/>
                    <circle cx="61" cy="95" r="3" fill="${eyePupil}"/>
                    <circle cx="63" cy="93" r="1.5" fill="white"/>
                    <!-- Right eye -->
                    <ellipse cx="92" cy="95" rx="10" ry="8" fill="${eyeWhite}" stroke="${lineColor}" stroke-width="1.5"/>
                    <ellipse cx="94" cy="96" rx="5" ry="5" fill="${eyeIris}"/>
                    <circle cx="95" cy="95" r="3" fill="${eyePupil}"/>
                    <circle cx="97" cy="93" r="1.5" fill="white"/>
                    <!-- Smile squint lines -->
                    <path d="M48 100 Q52 98 55 100" stroke="${skinShadow}" stroke-width="1" fill="none"/>
                    <path d="M95 100 Q98 98 102 100" stroke="${skinShadow}" stroke-width="1" fill="none"/>`;

                eyebrowsContent = `
                    <path d="M48 82 Q58 78 68 82" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <path d="M82 82 Q92 78 102 82" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>`;

                // Big toothy salesman grin
                mouthContent = `
                    <path d="M55 118 Q75 142 95 118" stroke="${lineColor}" stroke-width="2" fill="${mouthDark}"/>
                    <path d="M58 120 Q75 138 92 120" fill="${teethColor}"/>
                    <rect x="60" y="120" width="5" height="10" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>
                    <rect x="65" y="120" width="5" height="11" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>
                    <rect x="70" y="120" width="5" height="12" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>
                    <rect x="75" y="120" width="5" height="12" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>
                    <rect x="80" y="120" width="5" height="11" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>
                    <rect x="85" y="120" width="5" height="10" fill="${teethColor}" stroke="#eee" stroke-width="0.5"/>`;

                cheeksContent = `
                    <ellipse cx="45" cy="108" rx="8" ry="5" fill="#f0a0a0" opacity="0.3"/>
                    <ellipse cx="105" cy="108" rx="8" ry="5" fill="#f0a0a0" opacity="0.3"/>`;

            } else if (expression === 'laugh') {
                // Laughing maniacally
                eyesContent = `
                    <!-- Closed laughing eyes - arched up -->
                    <path d="M48 92 Q58 85 68 92" stroke="${lineColor}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
                    <path d="M82 92 Q92 85 102 92" stroke="${lineColor}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
                    <!-- Laugh lines -->
                    <path d="M46 96 Q50 94 52 96" stroke="${skinShadow}" stroke-width="1" fill="none"/>
                    <path d="M98 96 Q100 94 104 96" stroke="${skinShadow}" stroke-width="1" fill="none"/>`;

                eyebrowsContent = `
                    <path d="M48 80 Q58 74 68 80" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <path d="M82 80 Q92 74 102 80" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>`;

                // Wide open laughing mouth
                mouthContent = `
                    <ellipse cx="75" cy="125" rx="22" ry="18" fill="${mouthDark}" stroke="${lineColor}" stroke-width="2"/>
                    <path d="M55 120 Q75 115 95 120" fill="${teethColor}"/>
                    <ellipse cx="75" cy="135" rx="12" ry="6" fill="${tongueColor}"/>`;

                cheeksContent = `
                    <ellipse cx="42" cy="108" rx="10" ry="6" fill="#f0a0a0" opacity="0.4"/>
                    <ellipse cx="108" cy="108" rx="10" ry="6" fill="#f0a0a0" opacity="0.4"/>`;

                extraContent = `
                    <text x="75" y="10" text-anchor="middle" font-family="Bangers, sans-serif" font-size="14" fill="#ff4444" stroke="#000" stroke-width="0.5">HA HA!</text>`;

            } else if (expression === 'taunt') {
                // Smug taunting expression
                eyesContent = `
                    <!-- Sly narrowed eyes -->
                    <ellipse cx="58" cy="94" rx="10" ry="6" fill="${eyeWhite}" stroke="${lineColor}" stroke-width="1.5"/>
                    <ellipse cx="61" cy="95" rx="4" ry="4" fill="${eyeIris}"/>
                    <circle cx="62" cy="94" r="2.5" fill="${eyePupil}"/>
                    <circle cx="64" cy="92" r="1.2" fill="white"/>
                    <ellipse cx="92" cy="94" rx="10" ry="6" fill="${eyeWhite}" stroke="${lineColor}" stroke-width="1.5"/>
                    <ellipse cx="95" cy="95" rx="4" ry="4" fill="${eyeIris}"/>
                    <circle cx="96" cy="94" r="2.5" fill="${eyePupil}"/>
                    <circle cx="98" cy="92" r="1.2" fill="white"/>`;

                // One raised eyebrow
                eyebrowsContent = `
                    <path d="M48 80 Q58 82 68 78" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <path d="M82 78 Q92 82 102 80" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>`;

                // Smirk
                mouthContent = `
                    <path d="M55 122 Q70 128 95 115" stroke="${lineColor}" stroke-width="2.5" fill="none"/>
                    <path d="M58 120 Q72 126 90 116" fill="${teethColor}" stroke="none"/>`;

                cheeksContent = `<ellipse cx="100" cy="110" rx="8" ry="5" fill="#f0a0a0" opacity="0.3"/>`;

            } else if (expression === 'hit') {
                // Pained/hurt expression
                eyesContent = `
                    <!-- X eyes -->
                    <line x1="52" y1="88" x2="64" y2="100" stroke="${lineColor}" stroke-width="3" stroke-linecap="round"/>
                    <line x1="64" y1="88" x2="52" y2="100" stroke="${lineColor}" stroke-width="3" stroke-linecap="round"/>
                    <line x1="86" y1="88" x2="98" y2="100" stroke="${lineColor}" stroke-width="3" stroke-linecap="round"/>
                    <line x1="98" y1="88" x2="86" y2="100" stroke="${lineColor}" stroke-width="3" stroke-linecap="round"/>`;

                eyebrowsContent = `
                    <path d="M48 82 Q58 88 68 82" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <path d="M82 82 Q92 88 102 82" stroke="${hairDark}" stroke-width="3" fill="none" stroke-linecap="round"/>`;

                // Pained O mouth
                mouthContent = `
                    <ellipse cx="75" cy="125" rx="12" ry="15" fill="${mouthDark}" stroke="${lineColor}" stroke-width="2"/>`;

                extraContent = `
                    <!-- Impact stars -->
                    <text x="30" y="60" font-size="16">‚≠ê</text>
                    <text x="115" y="55" font-size="14">üí´</text>
                    <text x="20" y="85" font-size="12">‚ú®</text>`;
            }

            return `
            <svg viewBox="0 0 150 200" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="skinGrad${uid}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="${skinHighlight}"/>
                        <stop offset="50%" stop-color="${skin}"/>
                        <stop offset="100%" stop-color="${skinShade}"/>
                    </linearGradient>
                    <linearGradient id="suitGrad${uid}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="${suitHighlight}"/>
                        <stop offset="50%" stop-color="${suitMain}"/>
                        <stop offset="100%" stop-color="${suitDark}"/>
                    </linearGradient>
                    <linearGradient id="hairGrad${uid}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="${hairHighlight}"/>
                        <stop offset="40%" stop-color="${hairMain}"/>
                        <stop offset="100%" stop-color="${hairDark}"/>
                    </linearGradient>
                    <linearGradient id="tieGrad${uid}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="${tieHighlight}"/>
                        <stop offset="50%" stop-color="${tieMain}"/>
                        <stop offset="100%" stop-color="${tieDark}"/>
                    </linearGradient>
                    <filter id="shadow${uid}">
                        <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.3"/>
                    </filter>
                </defs>

                <!-- BODY / SHOULDERS -->
                <g filter="url(#shadow${uid})">
                    <!-- Suit jacket body -->
                    <path d="M30 158 L20 200 L130 200 L120 158 Q100 165 75 160 Q50 165 30 158"
                          fill="url(#suitGrad${uid})" stroke="${lineColor}" stroke-width="1.5"/>

                    <!-- Suit lapels - V shape -->
                    <path d="M55 160 L45 185 L60 178 L75 195 L90 178 L105 185 L95 160"
                          fill="${suitDark}" stroke="${lineColor}" stroke-width="1"/>

                    <!-- White shirt visible -->
                    <path d="M60 163 L75 188 L90 163" fill="${shirtColor}" stroke="#ddd" stroke-width="0.5"/>

                    <!-- TIE - Yellow/Gold - KEY FEATURE -->
                    <path d="M70 165 L80 165 L84 200 L75 205 L66 200 Z"
                          fill="url(#tieGrad${uid})" stroke="${lineColor}" stroke-width="1"/>
                    <!-- Tie knot -->
                    <path d="M71 165 L79 165 L77 172 L75 174 L73 172 Z"
                          fill="${tieDark}" stroke="${lineColor}" stroke-width="0.5"/>
                    <!-- Tie stripe detail -->
                    <line x1="75" y1="175" x2="75" y2="195" stroke="${tieDark}" stroke-width="1" opacity="0.3"/>
                </g>

                <!-- REACHING HAND (extending to viewer's left) -->
                <g filter="url(#shadow${uid})">
                    <!-- Arm/sleeve -->
                    <path d="M35 165 Q10 160 -5 175" stroke="${suitMain}" stroke-width="22" fill="none" stroke-linecap="round"/>
                    <path d="M35 165 Q10 160 -5 175" stroke="${suitHighlight}" stroke-width="18" fill="none" stroke-linecap="round"/>

                    <!-- Shirt cuff -->
                    <ellipse cx="0" cy="178" rx="8" ry="5" fill="${shirtColor}" stroke="#ddd" stroke-width="0.5"/>

                    <!-- Hand palm -->
                    <ellipse cx="-8" cy="182" rx="14" ry="11" fill="${skin}" stroke="${lineColor}" stroke-width="1.2"/>

                    <!-- FINGERS - spread for handshake -->
                    <!-- Index finger -->
                    <path d="M-18 172 Q-25 168 -28 172 Q-30 176 -25 178 Q-20 178 -16 175"
                          fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <!-- Middle finger -->
                    <path d="M-20 178 Q-30 176 -33 180 Q-34 185 -28 186 Q-22 185 -18 182"
                          fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <!-- Ring finger -->
                    <path d="M-18 185 Q-28 185 -30 190 Q-30 194 -24 194 Q-18 192 -15 188"
                          fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <!-- Pinky -->
                    <path d="M-14 190 Q-22 192 -23 196 Q-22 200 -17 199 Q-12 196 -10 192"
                          fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <!-- Thumb -->
                    <path d="M2 175 Q8 168 5 162 Q0 160 -4 165 Q-6 172 0 177"
                          fill="${skin}" stroke="${lineColor}" stroke-width="1"/>

                    <!-- Finger creases/details -->
                    <path d="M-22 175 L-20 176" stroke="${skinShadow}" stroke-width="0.5"/>
                    <path d="M-26 183 L-24 184" stroke="${skinShadow}" stroke-width="0.5"/>
                    <path d="M-23 191 L-21 191" stroke="${skinShadow}" stroke-width="0.5"/>
                </g>

                <!-- NECK -->
                <rect x="62" y="145" width="26" height="18" fill="url(#skinGrad${uid})"/>
                <path d="M65 155 Q75 158 85 155" stroke="${skinShadow}" stroke-width="1" fill="none" opacity="0.4"/>

                <!-- HEAD -->
                <g filter="url(#shadow${uid})">
                    <!-- Face shape - slightly wider, friendly proportions -->
                    <ellipse cx="75" cy="90" rx="48" ry="55" fill="url(#skinGrad${uid})" stroke="${lineColor}" stroke-width="1.5"/>

                    <!-- Jaw definition -->
                    <path d="M35 100 Q30 120 45 140 Q60 152 75 155 Q90 152 105 140 Q120 120 115 100"
                          fill="none" stroke="${skinShadow}" stroke-width="1" opacity="0.3"/>

                    <!-- Ears -->
                    <ellipse cx="27" cy="95" rx="7" ry="12" fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <path d="M28 90 Q32 95 28 100" stroke="${skinShadow}" stroke-width="1" fill="none"/>
                    <ellipse cx="123" cy="95" rx="7" ry="12" fill="${skin}" stroke="${lineColor}" stroke-width="1"/>
                    <path d="M122 90 Q118 95 122 100" stroke="${skinShadow}" stroke-width="1" fill="none"/>

                    <!-- HAIR - Side parted on LEFT, sweeping right - CRITICAL -->
                    <!-- Main hair mass -->
                    <path d="M30 70
                             Q28 45 45 32
                             Q65 22 90 28
                             Q115 35 122 55
                             Q125 70 123 85
                             L120 70
                             Q118 55 100 48
                             Q75 40 55 50
                             Q40 58 35 75
                             Z"
                          fill="url(#hairGrad${uid})" stroke="${lineColor}" stroke-width="1.5"/>

                    <!-- Hair part line - on the LEFT side -->
                    <path d="M42 35 Q45 50 42 70" stroke="${hairDark}" stroke-width="2" fill="none"/>

                    <!-- Hair swooping to the right -->
                    <path d="M45 35 Q70 30 100 38 Q85 35 60 42 Q48 48 45 55"
                          fill="${hairHighlight}" opacity="0.4"/>

                    <!-- Hair texture lines -->
                    <path d="M50 38 Q65 32 85 36" stroke="${hairDark}" stroke-width="1" fill="none" opacity="0.5"/>
                    <path d="M55 42 Q70 38 90 42" stroke="${hairDark}" stroke-width="1" fill="none" opacity="0.4"/>
                    <path d="M48 50 Q60 45 75 48" stroke="${hairDark}" stroke-width="1" fill="none" opacity="0.3"/>

                    <!-- Hair over forehead - styled to the right -->
                    <path d="M42 55 Q50 48 70 50 Q55 55 45 65" fill="${hairMain}" opacity="0.7"/>

                    <!-- Sideburns -->
                    <path d="M30 70 L32 90 Q35 85 33 75 Z" fill="${hairMain}"/>
                    <path d="M120 70 L118 90 Q115 85 117 75 Z" fill="${hairMain}"/>

                    <!-- EYEBROWS -->
                    ${eyebrowsContent}

                    <!-- EYES -->
                    ${eyesContent}

                    <!-- NOSE - friendly, not too prominent -->
                    <path d="M75 90 L73 108 Q75 114 77 108 L75 90" fill="${skinShadow}" opacity="0.4"/>
                    <path d="M68 112 Q75 116 82 112" stroke="${skinShadow}" stroke-width="1" fill="none"/>

                    <!-- Nostrils hint -->
                    <circle cx="71" cy="111" r="2" fill="${skinShadow}" opacity="0.3"/>
                    <circle cx="79" cy="111" r="2" fill="${skinShadow}" opacity="0.3"/>

                    <!-- CHEEKS -->
                    ${cheeksContent}

                    <!-- MOUTH -->
                    ${mouthContent}

                    <!-- Smile/expression lines -->
                    <path d="M48 108 Q44 118 48 128" stroke="${skinShadow}" stroke-width="1" fill="none" opacity="0.3"/>
                    <path d="M102 108 Q106 118 102 128" stroke="${skinShadow}" stroke-width="1" fill="none" opacity="0.3"/>

                    <!-- Chin definition -->
                    <ellipse cx="75" cy="148" rx="12" ry="4" fill="${skinShadow}" opacity="0.15"/>
                </g>

                <!-- Type indicators -->
                ${isGolden ? `
                    <circle cx="75" cy="8" r="10" fill="none" stroke="#ffd700" stroke-width="2"/>
                    <text x="75" y="12" text-anchor="middle" font-size="14" fill="#ffd700">‚òÖ</text>
                ` : ''}
                ${isBomb ? `<text x="75" y="15" text-anchor="middle" font-size="18">üí£</text>` : ''}
                ${isBoss ? `<text x="75" y="15" text-anchor="middle" font-size="18">üëë</text>` : ''}
                ${isSpeed ? `<text x="75" y="15" text-anchor="middle" font-size="14">‚ö°</text>` : ''}
                ${isAngry ? `<text x="75" y="15" text-anchor="middle" font-size="14">üò§</text>` : ''}

                <!-- Extra expression content -->
                ${extraContent}
            </svg>`;
        }

        // =====================================================
        // RADIO SYSTEM - GTA STYLE WITH MULTIPLE STATIONS
        // =====================================================
        const Radio = {
            ctx: null,
            masterGain: null,
            compressor: null,
            playing: false,
            currentStation: 0,
            bar: 0,
            loopTimeout: null,

            stations: [
                { name: 'DARK DRIVE', freq: '66.6 FM', style: 'darkdrive', tempo: 128, color: '#ff0040' },
                { name: 'MIDNIGHT HUNTER', freq: '93.0 FM', style: 'hunter', tempo: 140, color: '#00ffff' },
                { name: 'NEON NOIR', freq: '80.5 FM', style: 'noir', tempo: 100, color: '#ff00ff' },
                { name: 'RAGE MODE', freq: '99.9 FM', style: 'rage', tempo: 160, color: '#ffff00' },
                { name: 'RADIO OFF', freq: '---.- FM', style: 'off', tempo: 0, color: '#333' }
            ],

            init() {
                try {
                    if (!this.ctx) {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume();
                    }
                    if (this.masterGain) return;

                    // Master gain
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.35;

                    // Compressor for that radio punch
                    this.compressor = this.ctx.createDynamicsCompressor();
                    this.compressor.threshold.value = -24;
                    this.compressor.knee.value = 30;
                    this.compressor.ratio.value = 12;
                    this.compressor.attack.value = 0.003;
                    this.compressor.release.value = 0.25;

                    // Delay for spacious sound
                    this.delay = this.ctx.createDelay(0.5);
                    this.delay.delayTime.value = 0.25;
                    this.delayGain = this.ctx.createGain();
                    this.delayGain.gain.value = 0.15;

                    // Connect: instruments -> compressor -> masterGain -> destination
                    // Delay path: instruments -> delay -> delayGain -> compressor
                    this.compressor.connect(this.masterGain);
                    this.masterGain.connect(this.ctx.destination);
                    this.delay.connect(this.delayGain);
                    this.delayGain.connect(this.compressor);
                } catch (e) {
                    console.error('Radio init error:', e);
                }
            },

            togglePower() {
                if (this.playing) {
                    this.stop();
                } else {
                    this.init();
                    this.start();
                }
            },

            start() {
                if (this.stations[this.currentStation].style === 'off') return;
                this.playing = true;
                this.bar = 0;
                this.playLoop();
            },

            stop() {
                this.playing = false;
                if (this.loopTimeout) clearTimeout(this.loopTimeout);
            },

            // ================== SOUND INSTRUMENTS ==================

            // Heavy 808 kick with punch
            playKick(delay = 0, style = 'normal') {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;

                // Main body
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';

                // Pitch envelope - different styles
                const startFreq = style === 'action' ? 200 : 150;
                const endFreq = style === 'action' ? 30 : 40;
                osc.frequency.setValueAtTime(startFreq, t);
                osc.frequency.exponentialRampToValueAtTime(endFreq, t + 0.1);

                // Volume envelope
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

                // Click transient
                const click = this.ctx.createOscillator();
                const clickGain = this.ctx.createGain();
                click.type = 'triangle';
                click.frequency.value = 1500;
                clickGain.gain.setValueAtTime(0.3, t);
                clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.02);

                osc.connect(gain);
                click.connect(clickGain);
                gain.connect(this.compressor);
                clickGain.connect(this.compressor);

                osc.start(t); click.start(t);
                osc.stop(t + 0.5); click.stop(t + 0.03);
                } catch (e) { console.error('playKick error:', e); }
            },

            // Punchy snare with lots of crack
            playSnare(delay = 0, style = 'normal') {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;

                // Noise burst
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const noiseGain = this.ctx.createGain();
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = style === 'action' ? 2000 : 1500;

                noiseGain.gain.setValueAtTime(style === 'action' ? 0.6 : 0.4, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

                // Body tone
                const body = this.ctx.createOscillator();
                const bodyGain = this.ctx.createGain();
                body.type = 'triangle';
                body.frequency.value = style === 'action' ? 250 : 200;
                bodyGain.gain.setValueAtTime(0.4, t);
                bodyGain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.compressor);
                body.connect(bodyGain);
                bodyGain.connect(this.compressor);

                noise.start(t); body.start(t);
                body.stop(t + 0.2);
                } catch (e) { console.error('playSnare error:', e); }
            },

            // Hi-hat
            playHiHat(delay = 0, open = false) {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;
                const duration = open ? 0.2 : 0.05;

                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;

                gain.gain.setValueAtTime(open ? 0.15 : 0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.compressor);

                noise.start(t);
                } catch (e) { console.error('playHiHat error:', e); }
            },

            // Thick synth bass
            playBass(freq, duration, delay = 0, style = 'normal') {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;

                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc1.type = 'sawtooth';
                osc1.frequency.value = freq;
                osc2.type = 'square';
                osc2.frequency.value = freq * 0.5;

                filter.type = 'lowpass';
                filter.Q.value = style === 'funk' ? 12 : 6;
                filter.frequency.setValueAtTime(style === 'funk' ? 2000 : 1000, t);
                filter.frequency.exponentialRampToValueAtTime(150, t + 0.1);

                gain.gain.setValueAtTime(0.35, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.compressor);

                osc1.start(t); osc2.start(t);
                osc1.stop(t + duration); osc2.stop(t + duration);
                } catch (e) { console.error('playBass error:', e); }
            },

            // Synth lead with detuned oscillators
            playLead(freq, duration, delay = 0) {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;

                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                filter.Q.value = 3;

                [-10, 0, 10].forEach(detune => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    osc.detune.value = detune;
                    osc.connect(filter);
                    osc.start(t);
                    osc.stop(t + duration);
                });

                filter.frequency.setValueAtTime(1500, t);
                filter.frequency.linearRampToValueAtTime(4000, t + 0.05);
                filter.frequency.exponentialRampToValueAtTime(1500, t + duration);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.12, t + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

                filter.connect(gain);
                gain.connect(this.compressor);
                gain.connect(this.delay);
                } catch (e) { console.error('playLead error:', e); }
            },

            // Synth pad
            playPad(notes, duration, delay = 0) {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;

                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                notes.forEach(freq => {
                    [-5, 0, 5].forEach(detune => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        osc.detune.value = detune;
                        osc.connect(filter);
                        osc.start(t);
                        osc.stop(t + duration);
                    });
                });

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 0.3);
                gain.gain.setValueAtTime(0.05, t + duration - 0.3);
                gain.gain.linearRampToValueAtTime(0.001, t + duration);

                filter.connect(gain);
                gain.connect(this.compressor);
                } catch (e) { console.error('playPad error:', e); }
            },

            // Arpeggiator
            playArp(notes, duration, delay = 0) {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const noteLen = duration / notes.length;

                notes.forEach((freq, i) => {
                    const t = this.ctx.currentTime + delay + (i * noteLen);
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = 'square';
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.06, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.8);

                    osc.connect(gain);
                    gain.connect(this.delay);
                    gain.connect(this.compressor);

                    osc.start(t);
                    osc.stop(t + noteLen);
                });
                } catch (e) { console.error('playArp error:', e); }
            },

            // Stab chord for accents
            playStab(notes, duration, delay = 0) {
                if (!this.ctx || !this.playing || !this.compressor) return;
                try {
                const t = this.ctx.currentTime + delay;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 5000;
                filter.Q.value = 2;

                notes.forEach(freq => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    osc.connect(filter);
                    osc.start(t);
                    osc.stop(t + duration);
                });

                filter.frequency.setValueAtTime(5000, t);
                filter.frequency.exponentialRampToValueAtTime(500, t + duration);

                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

                filter.connect(gain);
                gain.connect(this.compressor);
                } catch (e) { console.error('playStab error:', e); }
            },

            // ================== DARK NIGHT MUSIC LOOPS ==================

            playLoop() {
                if (!this.playing) return;

                const station = this.stations[this.currentStation];
                if (station.style === 'off') return;

                const beat = 60 / station.tempo;
                const barLength = beat * 4;

                switch (station.style) {
                    case 'darkdrive': this.playDarkDrive(beat); break;
                    case 'hunter': this.playHunter(beat); break;
                    case 'noir': this.playNoir(beat); break;
                    case 'rage': this.playRage(beat); break;
                }

                this.bar++;
                this.loopTimeout = setTimeout(() => this.playLoop(), barLength * 1000);
            },

            // DARK DRIVE - Aggressive darksynth, Perturbator/Carpenter Brut style
            playDarkDrive(beat) {
                // Dark minor progressions - Em, Bm, Am, B
                const dark = [
                    { root: 82, pad: [165, 196, 247], stab: [330, 392, 494] },
                    { root: 123, pad: [247, 294, 370], stab: [494, 587, 740] },
                    { root: 110, pad: [220, 262, 330], stab: [440, 523, 659] },
                    { root: 123, pad: [247, 311, 370], stab: [494, 622, 740] }
                ];
                const d = dark[this.bar % 4];

                // Ominous droning pad
                this.playPad(d.pad, beat * 4.5, 0);

                // Pounding four-on-the-floor with aggression
                for (let i = 0; i < 4; i++) {
                    this.playKick(i * beat, 'action');
                    // Double kicks for intensity
                    this.playKick(i * beat + beat * 0.5, 'action');
                    // Hard snare on 2 and 4
                    if (i === 1 || i === 3) this.playSnare(i * beat, 'action');
                    // Crushing offbeat snares every other bar
                    if (this.bar % 2 === 1 && i === 2) this.playSnare(i * beat + beat * 0.5, 'action');
                    // Relentless 16th hi-hats
                    for (let j = 0; j < 4; j++) {
                        this.playHiHat(i * beat + j * beat * 0.25, j === 2);
                    }
                }

                // Driving distorted bass - 8th notes
                for (let i = 0; i < 8; i++) {
                    const note = i % 2 === 0 ? d.root : d.root * 0.75;
                    this.playBass(note, beat * 0.4, i * beat * 0.5, 'action');
                }

                // Aggressive stab hits
                this.playStab(d.stab, beat * 0.2, 0);
                this.playStab(d.stab, beat * 0.15, beat * 1.5);
                this.playStab(d.stab, beat * 0.2, beat * 2);
                this.playStab(d.stab, beat * 0.15, beat * 3.5);

                // Screaming lead melody - minor scale aggression
                const melodies = [
                    [659, 622, 494, 440, 494, 622, 494, 440],
                    [494, 440, 370, 330, 370, 440, 370, 330],
                    [440, 494, 587, 494, 440, 370, 330, 370],
                    [587, 622, 740, 622, 587, 494, 440, 494]
                ];
                const mel = melodies[this.bar % 4];
                mel.forEach((note, i) => {
                    if (i % 2 === 0) this.playLead(note, beat * 0.4, i * beat * 0.5);
                });

                // Dark arpeggios
                const arp = [d.root, d.root * 1.5, d.root * 2, d.root * 3, d.root * 4];
                this.playArp(arp, beat * 2, 0);
                this.playArp([...arp].reverse(), beat * 2, beat * 2);
            },

            // MIDNIGHT HUNTER - Cyberpunk chase music
            playHunter(beat) {
                // Tension building minor/diminished
                const hunt = [
                    { root: 110, stab: [220, 262, 330] },
                    { root: 104, stab: [208, 262, 311] },
                    { root: 98, stab: [196, 247, 294] },
                    { root: 117, stab: [233, 294, 349] }
                ];
                const h = hunt[this.bar % 4];

                // Machine gun kick pattern
                for (let i = 0; i < 4; i++) {
                    this.playKick(i * beat, 'action');
                    this.playKick(i * beat + beat * 0.25, 'action');
                    this.playKick(i * beat + beat * 0.5, 'action');
                    this.playKick(i * beat + beat * 0.75, 'action');
                    // Snare on every beat for urgency
                    this.playSnare(i * beat + beat * 0.5, 'action');
                    // 32nd note hi-hats - pure aggression
                    for (let j = 0; j < 8; j++) {
                        this.playHiHat(i * beat + j * beat * 0.125, j % 3 === 0);
                    }
                }

                // Pumping sidechained bass
                for (let i = 0; i < 16; i++) {
                    const note = i % 4 === 0 ? h.root : (i % 2 === 0 ? h.root * 0.75 : h.root * 0.5);
                    this.playBass(note, beat * 0.12, i * beat * 0.25, 'action');
                }

                // Staccato stabs - create urgency
                for (let i = 0; i < 8; i++) {
                    if (i % 2 === 0 || i === 5) {
                        this.playStab(h.stab, beat * 0.1, i * beat * 0.5);
                    }
                }

                // Frantic lead lines
                const frantic = [
                    [880, 830, 740, 659, 740, 880, 988, 880],
                    [659, 740, 880, 740, 659, 587, 523, 587],
                    [740, 830, 880, 988, 880, 740, 659, 740],
                    [988, 880, 740, 659, 587, 659, 740, 880]
                ];
                const line = frantic[this.bar % 4];
                line.forEach((note, i) => {
                    this.playLead(note, beat * 0.2, i * beat * 0.5);
                });

                // Rapid fire arpeggios
                const rapidArp = [h.root * 2, h.root * 2.5, h.root * 3, h.root * 4, h.root * 5, h.root * 6, h.root * 4, h.root * 3];
                this.playArp(rapidArp, beat * 2, 0);
                this.playArp(rapidArp.reverse(), beat * 2, beat * 2);
            },

            // NEON NOIR - Dark atmospheric, slower but menacing
            playNoir(beat) {
                // Noir jazz minor progressions
                const noir = [
                    { root: 73, pad: [147, 175, 220, 262], bass: 37 },
                    { root: 82, pad: [165, 196, 247, 294], bass: 41 },
                    { root: 65, pad: [131, 165, 196, 247], bass: 33 },
                    { root: 87, pad: [175, 208, 262, 311], bass: 44 }
                ];
                const n = noir[this.bar % 4];

                // Deep atmospheric pad
                this.playPad(n.pad, beat * 5, 0);

                // Sparse but heavy drums
                for (let i = 0; i < 4; i++) {
                    if (i === 0 || i === 2) this.playKick(i * beat, 'action');
                    if (i === 1) this.playKick(i * beat + beat * 0.66);
                    if (i === 3) this.playKick(i * beat + beat * 0.33, 'action');
                    // Heavy snare
                    if (i === 1 || i === 3) this.playSnare(i * beat, 'action');
                    // Moody hi-hats
                    this.playHiHat(i * beat + beat * 0.5, true);
                    if (i % 2 === 0) this.playHiHat(i * beat, false);
                }

                // Deep rumbling bass
                this.playBass(n.bass, beat * 2, 0, 'action');
                this.playBass(n.bass * 1.5, beat * 1.5, beat * 2, 'action');

                // Haunting lead melody
                const haunt = [
                    [330, 0, 294, 262, 0, 294, 330, 0],
                    [262, 0, 247, 220, 0, 247, 262, 0],
                    [294, 0, 262, 247, 0, 262, 294, 330],
                    [349, 330, 294, 0, 262, 294, 330, 0]
                ];
                const h = haunt[this.bar % 4];
                h.forEach((note, i) => {
                    if (note > 0) this.playLead(note, beat * 0.8, i * beat * 0.5);
                });

                // Dark stabs on phrase endings
                if (this.bar % 2 === 1) {
                    this.playStab(n.pad.slice(0, 3), beat * 0.8, beat * 3);
                }

                // Slow menacing arpeggio
                const darkArp = [n.root, n.root * 1.2, n.root * 1.5, n.root * 2, n.root * 2.5, n.root * 3];
                this.playArp(darkArp, beat * 4, 0);
            },

            // RAGE MODE - Maximum aggression industrial
            playRage(beat) {
                // Dissonant industrial
                const rage = [
                    { root: 55, stab: [110, 139, 165] },
                    { root: 58, stab: [117, 147, 175] },
                    { root: 52, stab: [104, 131, 156] },
                    { root: 62, stab: [123, 156, 185] }
                ];
                const r = rage[this.bar % 4];

                // Brutal kick pattern - every 8th note
                for (let i = 0; i < 8; i++) {
                    this.playKick(i * beat * 0.5, 'action');
                }

                // Snare assault
                for (let i = 0; i < 4; i++) {
                    this.playSnare(i * beat, 'action');
                    this.playSnare(i * beat + beat * 0.25, 'action');
                    if (this.bar % 2 === 0) this.playSnare(i * beat + beat * 0.5, 'action');
                    // Relentless hi-hats
                    for (let j = 0; j < 8; j++) {
                        this.playHiHat(i * beat + j * beat * 0.125, j % 2 === 0);
                    }
                }

                // Crushing sub bass
                for (let i = 0; i < 16; i++) {
                    this.playBass(r.root, beat * 0.15, i * beat * 0.25, 'action');
                }

                // Wall of stab noise
                for (let i = 0; i < 4; i++) {
                    this.playStab(r.stab, beat * 0.3, i * beat);
                    this.playStab(r.stab.map(n => n * 2), beat * 0.2, i * beat + beat * 0.5);
                }

                // Chaotic lead screams
                const chaos = [
                    [880, 932, 880, 740, 880, 932, 988, 880],
                    [740, 784, 880, 784, 740, 659, 740, 784],
                    [659, 740, 784, 880, 784, 740, 659, 587],
                    [988, 932, 880, 784, 880, 988, 1047, 988]
                ];
                const c = chaos[this.bar % 4];
                c.forEach((note, i) => {
                    this.playLead(note, beat * 0.2, i * beat * 0.5);
                });

                // Insane speed arpeggios
                const insaneArp = [];
                for (let i = 0; i < 16; i++) {
                    insaneArp.push(r.root * (2 + (i % 4)));
                }
                this.playArp(insaneArp, beat * 4, 0);
            }
        };

        // Legacy Music object for compatibility
        const Music = {
            init() { Radio.init(); },
            startGameMusic() { if (!Radio.playing) Radio.start(); },
            stop() { Radio.stop(); },
            toggle() { Radio.togglePower(); return Radio.playing; }
        };

        // =====================================================
        // SOUND EFFECTS - Simple and reliable
        // =====================================================
        const SFX = {
            ctx: null,

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // Simple tone generator
            beep(freq, dur, type = 'square', vol = 0.3) {
                try {
                    this.init();
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.value = freq;
                    gain.gain.value = vol;
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + dur);
                } catch (e) {}
            },

            hit() {
                this.beep(300, 0.1, 'square', 0.4);
                this.beep(150, 0.15, 'sine', 0.3);
            },

            golden() {
                this.beep(523, 0.1, 'sine', 0.3);
                setTimeout(() => this.beep(659, 0.1, 'sine', 0.3), 50);
                setTimeout(() => this.beep(784, 0.15, 'sine', 0.3), 100);
                setTimeout(() => this.beep(1047, 0.2, 'sine', 0.25), 150);
            },

            miss() {
                this.beep(200, 0.15, 'sawtooth', 0.2);
            },

            bomb() {
                this.beep(80, 0.4, 'sine', 0.5);
                this.beep(60, 0.5, 'sine', 0.4);
            },

            laugh() {
                this.beep(400, 0.08, 'square', 0.2);
                setTimeout(() => this.beep(500, 0.08, 'square', 0.2), 100);
                setTimeout(() => this.beep(400, 0.08, 'square', 0.2), 200);
            },

            combo() {
                this.beep(400, 0.1, 'sine', 0.25);
                setTimeout(() => this.beep(500, 0.1, 'sine', 0.25), 50);
                setTimeout(() => this.beep(600, 0.1, 'sine', 0.25), 100);
                setTimeout(() => this.beep(800, 0.15, 'sine', 0.3), 150);
            },

            gameOver() {
                this.beep(400, 0.3, 'sine', 0.3);
                setTimeout(() => this.beep(350, 0.3, 'sine', 0.3), 200);
                setTimeout(() => this.beep(300, 0.3, 'sine', 0.3), 400);
                setTimeout(() => this.beep(200, 0.5, 'sine', 0.3), 600);
            }
        };

        // =====================================================
        // GAME STATE
        // =====================================================
        let score = 0, time = 60, hits = 0, misses = 0, combo = 0, maxCombo = 0, lives = 3;
        let running = false, paused = false, gameTimer, spawnTimer;
        let weapon = 'knife', mode = 'classic';
        let activeHanks = [];
        let lastHit = 0;
        let musicOn = false;
        let pausedTimeRemaining = 0;

        const weapons = {
            knife: { dmg: 1, cd: 120, mult: 1, cursor: 'üî™' },
            axe: { dmg: 2, cd: 300, mult: 1.2, cursor: 'ü™ì' },
            hammer: { dmg: 1.5, cd: 200, mult: 1.1, cursor: 'üî®' },
            sword: { dmg: 1, cd: 80, mult: 1, cursor: '‚öîÔ∏è' },
            bomb: { dmg: 3, cd: 400, mult: 2, cursor: 'üí£' }
        };

        const hankTypes = {
            normal: { pts: 100, dur: 2000, tauntTime: 1500 },
            golden: { pts: 500, dur: 1200, tauntTime: 800 },
            angry: { pts: 150, dur: 1500, tauntTime: 1000 },
            speed: { pts: 200, dur: 700, tauntTime: 500 },
            bomb: { pts: -500, dur: 1800, tauntTime: null },
            boss: { pts: 1000, dur: 8000, hp: 5, tauntTime: 2000 }
        };

        // DOM
        const board = document.getElementById('gameBoard');
        const scoreEl = document.getElementById('scoreValue');
        const timeEl = document.getElementById('timerValue');
        const comboEl = document.getElementById('comboValue');
        const livesEl = document.getElementById('livesValue');
        const cursor = document.getElementById('cursor');
        const flash = document.getElementById('hitFlash');
        const comboPopup = document.getElementById('comboPopup');
        const startMenu = document.getElementById('startMenu');
        const gameOver = document.getElementById('gameOver');

        // =====================================================
        // VISUAL EFFECTS
        // =====================================================
        function shake() {
            document.body.classList.remove('shake');
            void document.body.offsetWidth;
            document.body.classList.add('shake');
        }

        function flashScreen(type) {
            flash.className = '';
            void flash.offsetWidth;
            flash.classList.add(type);
        }

        function popup(x, y, text, cls = '') {
            const p = document.createElement('div');
            p.className = 'popup ' + cls;
            p.textContent = text;
            p.style.left = x + 'px';
            p.style.top = y + 'px';
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 700);
        }

        function impact(x, y, color = '#ff4444') {
            const el = document.createElement('div');
            el.className = 'impact';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.innerHTML = `<svg width="100" height="100" viewBox="-50 -50 100 100">
                <polygon points="0,-45 12,-15 45,-15 18,5 28,45 0,20 -28,45 -18,5 -45,-15 -12,-15"
                         fill="${color}" stroke="#000" stroke-width="2"/>
                <text x="0" y="8" text-anchor="middle" font-family="Bangers" font-size="18" fill="white" stroke="#000" stroke-width="1">POW!</text>
            </svg>`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 400);
        }

        function particles(x, y, color = '#cc0000', count = 12) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.background = color;
                p.style.width = p.style.height = (6 + Math.random() * 8) + 'px';
                const angle = Math.random() * Math.PI * 2;
                const dist = 40 + Math.random() * 60;
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--ty', (Math.sin(angle) * dist - 30) + 'px');
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 600);
            }
        }

        function showCombo(num) {
            comboPopup.textContent = num + 'x COMBO!';
            comboPopup.classList.remove('show');
            void comboPopup.offsetWidth;
            comboPopup.classList.add('show');
            SFX.combo();
        }

        // =====================================================
        // GAME BOARD
        // =====================================================
        function initBoard() {
            board.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const hole = document.createElement('div');
                hole.className = 'hole';
                hole.innerHTML = `
                    <div class="hank-wrap" data-idx="${i}"></div>
                    <div class="health-bar"><div class="fill"></div></div>
                `;
                hole.addEventListener('click', e => handleClick(e, i));
                hole.addEventListener('touchstart', e => { e.preventDefault(); handleClick(e, i); }, { passive: false });
                board.appendChild(hole);
            }
        }

        // =====================================================
        // SPAWNING
        // =====================================================
        function getType() {
            const r = Math.random();
            if (mode === 'boss') return 'boss';
            if (r < 0.05) return 'bomb';
            if (r < 0.15) return 'golden';
            if (r < 0.28) return 'angry';
            if (r < 0.38) return 'speed';
            return 'normal';
        }

        function spawn() {
            if (!running) return;

            const free = [];
            for (let i = 0; i < 9; i++) {
                if (!activeHanks.find(h => h.idx === i)) free.push(i);
            }
            if (!free.length) {
                spawnTimer = setTimeout(spawn, 300);
                return;
            }

            const idx = free[Math.floor(Math.random() * free.length)];
            const type = getType();
            const data = hankTypes[type];

            const hole = board.children[idx];
            const wrap = hole.querySelector('.hank-wrap');
            const healthBar = hole.querySelector('.health-bar');

            // Set initial expression
            wrap.innerHTML = createHankSVG(type, 'smile');
            wrap.className = 'hank-wrap up idle ' + type;

            const obj = {
                idx, type,
                el: wrap,
                hp: data.hp || 1,
                expression: 'smile',
                taunted: false,
                tauntTimeout: data.tauntTime ? setTimeout(() => hankTaunts(idx), data.tauntTime) : null,
                hideTimeout: setTimeout(() => hideHank(idx, true), data.dur)
            };

            if (type === 'boss') {
                healthBar.classList.add('visible');
                healthBar.querySelector('.fill').style.width = '100%';
                obj.healthBar = healthBar;
            }

            activeHanks.push(obj);

            // Schedule next spawn
            const delay = mode === 'blitz' ? 400 + Math.random() * 400 : 600 + Math.random() * 800;
            spawnTimer = setTimeout(spawn, delay);
        }

        // =====================================================
        // HANK TAUNTS (laughs at you!)
        // =====================================================
        function hankTaunts(idx) {
            const obj = activeHanks.find(h => h.idx === idx);
            if (!obj || !obj.el.classList.contains('up') || obj.taunted) return;

            obj.taunted = true;
            obj.expression = 'taunt';

            // Change to taunting animation and expression
            obj.el.classList.remove('idle');
            obj.el.classList.add('taunting');
            obj.el.innerHTML = createHankSVG(obj.type, 'taunt');

            // After a moment, start laughing
            setTimeout(() => {
                if (!obj.el.classList.contains('up')) return;

                obj.expression = 'laugh';
                obj.el.classList.remove('taunting');
                obj.el.classList.add('laughing');
                obj.el.innerHTML = createHankSVG(obj.type, 'laugh');

                SFX.laugh();

                // Show HA HA text
                const rect = obj.el.getBoundingClientRect();
                popup(rect.left + rect.width/2, rect.top, 'HA HA!', 'laugh');

                // Throw something at player
                setTimeout(() => {
                    if (!obj.el.classList.contains('up')) return;
                    throwAtPlayer(obj);
                }, 400);
            }, 300);
        }

        function throwAtPlayer(obj) {
            const rect = obj.el.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 3;

            // Create thrown object
            const projectiles = ['üí∞', 'üíµ', 'ü™ô', 'üí≥', 'üí∏', 'üìà'];
            const thrown = document.createElement('div');
            thrown.className = 'thrown';
            thrown.textContent = projectiles[Math.floor(Math.random() * projectiles.length)];
            thrown.style.left = x + 'px';
            thrown.style.top = y + 'px';
            document.body.appendChild(thrown);

            SFX.throw();

            setTimeout(() => {
                thrown.remove();
                playerHit();
            }, 500);
        }

        function playerHit() {
            lives--;
            combo = 0;

            flashScreen('hurt');
            shake();
            SFX.hurt();

            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

            updateHUD();

            if (lives <= 0) endGame();
        }

        // =====================================================
        // HIDE HANK
        // =====================================================
        function hideHank(idx, escaped = false) {
            const obj = activeHanks.find(h => h.idx === idx);
            if (!obj) return;

            clearTimeout(obj.hideTimeout);
            clearTimeout(obj.tauntTimeout);

            obj.el.classList.remove('up', 'idle', 'laughing', 'taunting');

            if (obj.healthBar) obj.healthBar.classList.remove('visible');

            if (escaped && obj.type !== 'bomb') {
                combo = 0;
                updateHUD();
            }

            activeHanks = activeHanks.filter(h => h.idx !== idx);
        }

        // =====================================================
        // HIT HANDLING
        // =====================================================
        function handleClick(e, idx) {
            if (!running || paused) return;

            const now = Date.now();
            if (now - lastHit < weapons[weapon].cd) return;
            lastHit = now;

            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.clientX || e.touches?.[0]?.clientX || rect.left + rect.width/2;
            const y = e.clientY || e.touches?.[0]?.clientY || rect.top + rect.height/2;

            const obj = activeHanks.find(h => h.idx === idx);

            if (!obj || !obj.el.classList.contains('up')) {
                misses++;
                combo = 0;
                SFX.miss();
                popup(x, y, 'MISS', 'bad');
                updateHUD();
                return;
            }

            const type = obj.type;
            const data = hankTypes[type];

            // BOMB - Don't hit!
            if (type === 'bomb') {
                score = Math.max(0, score + data.pts);
                combo = 0;
                SFX.bomb();
                shake();
                flashScreen('red');
                impact(x, y, '#ff0000');
                particles(x, y, '#ff6600', 20);
                popup(x, y, data.pts, 'bad');

                if (mode === 'endless' || mode === 'blitz') {
                    lives--;
                    if (lives <= 0) endGame();
                }

                // Show hit expression briefly
                obj.el.innerHTML = createHankSVG(type, 'hit');
                obj.el.classList.add('hit');
                hideHank(idx);
                updateHUD();
                return;
            }

            // BOSS
            if (type === 'boss') {
                obj.hp -= weapons[weapon].dmg;
                obj.healthBar.querySelector('.fill').style.width = (obj.hp / data.hp * 100) + '%';

                SFX.hit();
                shake();
                particles(x, y, '#cc0000', 8);

                // Change expression to hit briefly
                obj.el.innerHTML = createHankSVG(type, 'hit');
                setTimeout(() => {
                    if (obj.el.classList.contains('up')) {
                        obj.el.innerHTML = createHankSVG(type, obj.expression);
                    }
                }, 150);

                if (obj.hp <= 0) {
                    // Boss defeated!
                    const pts = Math.round(data.pts * weapons[weapon].mult);
                    score += pts;
                    hits++;
                    combo++;
                    maxCombo = Math.max(maxCombo, combo);

                    SFX.golden();
                    flashScreen('gold');
                    impact(x, y, '#ffd700');
                    particles(x, y, '#ffd700', 25);
                    popup(x, y, '+' + pts, 'gold');

                    if (combo >= 5 && combo % 5 === 0) showCombo(combo);

                    obj.el.innerHTML = createHankSVG(type, 'hit');
                    obj.el.classList.add('hit');
                    obj.healthBar.classList.remove('visible');
                    clearTimeout(obj.hideTimeout);
                    clearTimeout(obj.tauntTimeout);
                    activeHanks = activeHanks.filter(h => h.idx !== idx);
                }

                updateHUD();
                return;
            }

            // NORMAL HIT
            let pts = Math.round(data.pts * weapons[weapon].mult * (1 + combo * 0.1));
            score += pts;
            hits++;
            combo++;
            maxCombo = Math.max(maxCombo, combo);

            if (type === 'golden') {
                SFX.golden();
                flashScreen('gold');
                impact(x, y, '#ffd700');
                particles(x, y, '#ffd700', 18);
                popup(x, y, '+' + pts, 'gold');
            } else {
                SFX.hit();
                shake();
                flashScreen('red');
                impact(x, y, '#ff4444');
                particles(x, y, '#cc0000', 12);
                popup(x, y, '+' + pts);
            }

            if (combo >= 5 && combo % 5 === 0) showCombo(combo);

            // Hit expression and animation
            obj.el.innerHTML = createHankSVG(type, 'hit');
            obj.el.classList.remove('idle', 'laughing', 'taunting');
            obj.el.classList.add('hit');

            clearTimeout(obj.hideTimeout);
            clearTimeout(obj.tauntTimeout);
            activeHanks = activeHanks.filter(h => h.idx !== idx);

            updateHUD();
        }

        // =====================================================
        // HUD
        // =====================================================
        function updateHUD() {
            scoreEl.textContent = score.toLocaleString();
            timeEl.textContent = mode === 'endless' ? '‚àû' : time;
            comboEl.textContent = combo + 'x';
            livesEl.textContent = '‚ù§Ô∏è'.repeat(Math.max(0, lives));

            timeEl.classList.toggle('danger', time <= 10 && mode !== 'endless');
        }

        // =====================================================
        // GAME FLOW
        // =====================================================
        function selectMode(m) {
            mode = m;
            document.querySelectorAll('.mode-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.mode === m);
            });
        }

        function selectWeapon(w) {
            weapon = w;
            cursor.textContent = weapons[w].cursor;
            document.querySelectorAll('.weapon-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.w === w);
            });
        }

        function toggleMusic() {
            Radio.togglePower();
            musicOn = Radio.playing;
            const btn = document.getElementById('musicToggle');
            btn.classList.toggle('playing', musicOn);
            btn.classList.toggle('off', !musicOn);
        }

        // Pause/Resume functionality
        function togglePause() {
            if (!running) return;

            paused = !paused;
            const pauseMenu = document.getElementById('pauseMenu');
            const pauseBtn = document.getElementById('pauseBtn');

            if (paused) {
                // Pause the game
                pauseMenu.classList.add('show');
                pauseBtn.textContent = '‚ñ∂';
                clearInterval(gameTimer);
                clearTimeout(spawnTimer);
                // Pause all active Hank timeouts
                activeHanks.forEach(h => {
                    clearTimeout(h.hideTimeout);
                    clearTimeout(h.tauntTimeout);
                });
                // Pause music
                if (Radio.playing) {
                    Radio.stop();
                }
            } else {
                // Resume the game
                pauseMenu.classList.remove('show');
                pauseBtn.textContent = '‚è∏';
                // Restart timer
                if (mode !== 'endless') {
                    gameTimer = setInterval(() => {
                        time--;
                        updateHUD();
                        if (time <= 0) endGame();
                    }, 1000);
                }
                // Resume spawning
                setTimeout(spawn, 500);
                // Resume music
                if (musicOn) {
                    Radio.init();
                    Radio.start();
                }
            }
        }

        function quitToMenu() {
            paused = false;
            running = false;
            document.getElementById('pauseMenu').classList.remove('show');
            document.getElementById('pauseBtn').textContent = '‚è∏';
            clearInterval(gameTimer);
            clearTimeout(spawnTimer);
            activeHanks.forEach(h => {
                clearTimeout(h.hideTimeout);
                clearTimeout(h.tauntTimeout);
            });
            activeHanks = [];
            Radio.stop();
            showMenu();
        }

        // Auto-start music on first user interaction
        function autoStartMusic() {
            if (!musicOn) {
                try {
                    SFX.init();
                    Radio.init();
                    // Start the radio
                    setTimeout(() => {
                        if (Radio.ctx) {
                            if (Radio.ctx.state === 'suspended') {
                                Radio.ctx.resume().then(() => {
                                    Radio.start();
                                    musicOn = true;
                                    document.getElementById('musicToggle').classList.add('playing');
                                });
                            } else {
                                Radio.start();
                                musicOn = true;
                                document.getElementById('musicToggle').classList.add('playing');
                            }
                        }
                    }, 100);
                } catch (e) {
                    console.warn('Audio init error:', e);
                }
            }
            // Remove listeners after first interaction
            document.removeEventListener('click', autoStartMusic);
            document.removeEventListener('touchstart', autoStartMusic);
            document.removeEventListener('keydown', autoStartMusic);
        }

        function startGame() {
            score = 0;
            time = mode === 'blitz' ? 30 : 60;
            hits = 0;
            misses = 0;
            combo = 0;
            maxCombo = 0;
            lives = 3;
            activeHanks = [];

            SFX.init();
            Radio.init();
            // Start radio if not already playing
            if (!Radio.playing && Radio.stations[Radio.currentStation].style !== 'off') {
                Radio.start();
                musicOn = true;
            }

            startMenu.classList.add('hidden');
            gameOver.classList.add('hidden');
            initBoard();
            updateHUD();

            running = true;

            if (mode !== 'endless') {
                gameTimer = setInterval(() => {
                    time--;
                    updateHUD();
                    if (time <= 0) endGame();
                }, 1000);
            }

            setTimeout(spawn, 500);
        }

        function endGame() {
            running = false;
            // Don't stop radio on game over - let it keep playing

            clearInterval(gameTimer);
            clearTimeout(spawnTimer);

            activeHanks.forEach(h => {
                clearTimeout(h.hideTimeout);
                clearTimeout(h.tauntTimeout);
            });
            activeHanks = [];

            SFX.gameOver();

            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('finalHits').textContent = hits;
            document.getElementById('finalCombo').textContent = maxCombo + 'x';
            document.getElementById('finalAcc').textContent =
                (hits + misses > 0) ? Math.round(hits / (hits + misses) * 100) + '%' : '0%';

            gameOver.classList.remove('hidden');
        }

        function showMenu() {
            gameOver.classList.add('hidden');
            startMenu.classList.remove('hidden');
        }

        // =====================================================
        // CURSOR
        // =====================================================
        document.addEventListener('mousemove', e => {
            cursor.style.left = (e.clientX - 20) + 'px';
            cursor.style.top = (e.clientY - 20) + 'px';
        });

        document.addEventListener('mousedown', () => cursor.style.transform = 'scale(0.8) rotate(-20deg)');
        document.addEventListener('mouseup', () => cursor.style.transform = '');

        // Keyboard controls
        document.addEventListener('keydown', e => {
            const keys = ['1','2','3','4','5'];
            const weps = ['knife','axe','hammer','sword','bomb'];
            const i = keys.indexOf(e.key);
            if (i >= 0 && !paused) selectWeapon(weps[i]);

            if ((e.key === ' ' || e.key === 'Enter') && !running && !paused) {
                startGame();
            }
            // Pause controls
            if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && running) {
                togglePause();
            }
            // Music controls
            if (e.key === 'm' || e.key === 'M') toggleMusic();
        });

        // Init
        initBoard();

        // Auto-start radio on first user interaction
        document.addEventListener('click', autoStartMusic, { once: true });
        document.addEventListener('touchstart', autoStartMusic, { once: true });
        document.addEventListener('keydown', autoStartMusic, { once: true });
    </script>
</body>
</html>
